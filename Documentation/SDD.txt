System design document for Multiplaya

Table of Contents
blaha~

  Version: 1

  Date 2012-04-26

  Author Niklas Andreasson, Niklas Logren, Jonathan Orr√∂, Felix Willebrand Westin

This version overrides all previous versions.


1 Introduction

1.1 Design goals
The design should be loosey coupled, and follow the Model-View-Controller pattern.
It should be testable, and allow for easy networking.


1.2 Definitions, acronyms and abbreviations
FPS - Frames per second.
GUI - Graphical User Interface
Host - The computer which hosts the game, and keeps track of all players (among other things).
Client - The computer(s) which connect to the host.
MVC - Model-View-Controller, a design pattern.


2 System design

2.1 Overview 
The design follows the Model-View-Controller pattern.
The application will be run in two threads: One for the model, and one for the view.
This two-threaded setup assures that all game logic is updated consistently, regardless of how good the game runs
on any one user's computer.
The controller is what creates these two threads.


2.1.1 The Model
The model is where the game state is saved, and all calculations are performed.

The entire game state is represented here, most notably the map and all physical objects (characters and bullets).
All mutable things, i.e. the physical objects, are saved in the WorldData class, which is used for communicating
with other parts of the program. The static world and the physics engine exists in the World class.

Everything is stored and calculated using the physics framework Box2D. The physical objects available consists of 
Characters or Bullets, which are both represented using (x,y)-coordinates and a force vector.

The World class is also what houses the "logic loop". This essentially performs all calculations, which includes applying the
force vectors on the objects to make them move, and executing collision checks.

Since this logic loop is in its own thread, it is run continuously at a set interval independent from the FPS of the view
(more on that later). This allows the game's graphics to be a bit "laggy", while still maintaining a precisely updated world.


2.1.1 The View
The view represents the actual window and graphics of the game.

All bullets and characters has graphical representations, which are stored here. Each graphical representation has a
reference to its model counterpart, from where it retrieves its coordinates and other information needed to display it.
We are using the graphical framework SFML for storing the sprites of characters, and for handling the actual window.

In the view we have a "graphics loop", which continuously polls the WorldData class asking for new data, and draws all our
graphical representations to the screen. Since this is also run in a separate thread, it can execute at any pace which the
computer allows, without affecting the game logic. This is especially important as we need to maintain a consistent game logic
for all players.



-------------------------------------------------------------------------------------------------------------------------




2.2 Software decomposition

2.2.1 General
The application is decomposed into the following modules:

view - Handles the window, and draws the game to the screen.
model - Handles the game world, and performs all necessary physic checks.
services - contains several subsystems.


2.2.2 Decomposition into subsystems
The project has several subsystems, all located within the folder "services".

services/confighandler - Handles the loading of configuration files.
services/networkhandler - Handles all networking.
services/resourcehandler - Handles all resources, i.e. textures.


2.2.2 Layering
???


2.2.3 Dependency analysis
???


2.3 Concurrency issues
The application consists of two threads, one for the game logics and one for displaying the graphics.
The view thread communicates with the model thread using the WorldData class, which contains all information which
is relevant to the view (e.g. the position and rotation of all objects). The WorldData class is locked using a mutex
when it is being accessed.


2.4 Persistent data management
Persistent configuration files are stored and accessed using the ConfigHandler class.


2.5 Access control and security
N/A


2.6 Boundary conditions 
N/A


3 References

  APPENDIX 


