<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>SFML - Simple and Fast Multimedia Library</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="tabs.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div id="logo">
            <img src="./logo.jpg" width="770" height="200" title="SFML home" alt="SFML logo" />
        </div>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.htm"><span>Classes</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.htm"><span>Class&#160;List</span></a></li>
      <li><a href="classes.htm"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.htm"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.htm"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>sf</b>      </li>
      <li class="navelem"><a class="el" href="classsf_1_1RenderTexture.htm">RenderTexture</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">sf::RenderTexture Class Reference<div class="ingroups"><a class="el" href="group__graphics.htm">Graphics module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="sf::RenderTexture" --><!-- doxytag: inherits="sf::RenderTarget" -->
<p>Target for off-screen 2D rendering into an texture.  
 <a href="classsf_1_1RenderTexture.htm#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RenderTexture_8hpp_source.htm">RenderTexture.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sf::RenderTexture:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsf_1_1RenderTexture.png" usemap="#sf::RenderTexture_map" alt=""/>
  <map id="sf::RenderTexture_map" name="sf::RenderTexture_map">
<area href="classsf_1_1RenderTarget.htm" title="Base class for all render targets (window, texture, ...)" alt="sf::RenderTarget" shape="rect" coords="0,56,111,80"/>
<area href="classsf_1_1NonCopyable.htm" title="Utility class that makes any derived class non-copyable." alt="sf::NonCopyable" shape="rect" coords="0,0,111,24"/>
</map>
 </div></div>

<p><a href="classsf_1_1RenderTexture-members.htm">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.htm#a19ee6e5b4c40ad251803389b3953a9c6">RenderTexture</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a19ee6e5b4c40ad251803389b3953a9c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.htm#a94b84ab9335be84d2a014c964d973304">~RenderTexture</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a94b84ab9335be84d2a014c964d973304"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.htm#aefbb76eb3b87e368ab974b2660931ccb">create</a> (unsigned int width, unsigned int height, bool depthBuffer=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the render-texture.  <a href="#aefbb76eb3b87e368ab974b2660931ccb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.htm#af08991e63c6020865dd07b20e27305b6">setSmooth</a> (bool smooth)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable texture smoothing.  <a href="#af08991e63c6020865dd07b20e27305b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.htm#ae385f4f4dbd2af50fb11947bf0bcb83d">isSmooth</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether the smooth filtering is enabled or not.  <a href="#ae385f4f4dbd2af50fb11947bf0bcb83d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.htm#a5da95ecdbce615a80bb78399012508cf">setActive</a> (bool active=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate of deactivate the render-texture for rendering.  <a href="#a5da95ecdbce615a80bb78399012508cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.htm#af92886d5faef3916caff9fa9ab32c555">display</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the contents of the target texture.  <a href="#af92886d5faef3916caff9fa9ab32c555"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsf_1_1Vector2.htm">Vector2u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.htm#a757ba45ec7a7deefcaef717049b00b8c">getSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the rendering region of the texture.  <a href="#a757ba45ec7a7deefcaef717049b00b8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1Texture.htm">Texture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.htm#a95bc5152c497066d31fdc57da8e17678">getTexture</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read-only reference to the target texture.  <a href="#a95bc5152c497066d31fdc57da8e17678"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a6bb6f0ba348f2b1e2f46114aeaf60f26">clear</a> (const <a class="el" href="classsf_1_1Color.htm">Color</a> &amp;color=<a class="el" href="classsf_1_1Color.htm">Color</a>(0, 0, 0, 255))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the entire target with a single color.  <a href="#a6bb6f0ba348f2b1e2f46114aeaf60f26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a063db6dd0a14913504af30e50cb6d946">setView</a> (const <a class="el" href="classsf_1_1View.htm">View</a> &amp;view)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the current active view.  <a href="#a063db6dd0a14913504af30e50cb6d946"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1View.htm">View</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a98f721cc6dc11478922427fedfb2288b">getView</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the view currently in use in the render target.  <a href="#a98f721cc6dc11478922427fedfb2288b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1View.htm">View</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a718b1aa6296bf855171699cc18251ced">getDefaultView</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default view of the render target.  <a href="#a718b1aa6296bf855171699cc18251ced"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Rect.htm">IntRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#aae035b0d45f87a0da2a28a0de6ba1086">getViewport</a> (const <a class="el" href="classsf_1_1View.htm">View</a> &amp;view) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the viewport of a view, applied to this render target.  <a href="#aae035b0d45f87a0da2a28a0de6ba1086"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#afc047333937f7cb7fe557aec60239233">convertCoords</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2i</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from target coordinates to view coordinates.  <a href="#afc047333937f7cb7fe557aec60239233"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#ae5e7ba65ef73df2778b29b7fdcdb20ee">convertCoords</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2i</a> &amp;point, const <a class="el" href="classsf_1_1View.htm">View</a> &amp;view) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from target coordinates to view coordinates.  <a href="#ae5e7ba65ef73df2778b29b7fdcdb20ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a12417a3bcc245c41d957b29583556f39">draw</a> (const <a class="el" href="classsf_1_1Drawable.htm">Drawable</a> &amp;drawable, const <a class="el" href="classsf_1_1RenderStates.htm">RenderStates</a> &amp;states=<a class="el" href="classsf_1_1RenderStates.htm#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a drawable object to the render-target.  <a href="#a12417a3bcc245c41d957b29583556f39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#ab636d7363f6681077361ee274ba89a8d">draw</a> (const <a class="el" href="classsf_1_1Vertex.htm">Vertex</a> *vertices, unsigned int vertexCount, <a class="el" href="group__graphics.htm#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a> type, const <a class="el" href="classsf_1_1RenderStates.htm">RenderStates</a> &amp;states=<a class="el" href="classsf_1_1RenderStates.htm#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives defined by an array of vertices.  <a href="#ab636d7363f6681077361ee274ba89a8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a8d1998464ccc54e789aaf990242b47f7">pushGLStates</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the current OpenGL render states and matrices.  <a href="#a8d1998464ccc54e789aaf990242b47f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#ad5a98401113df931ddcd54c080f7aa8e">popGLStates</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the previously saved OpenGL render states and matrices.  <a href="#ad5a98401113df931ddcd54c080f7aa8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#aac7504990d27dada4bfe3c7866920765">resetGLStates</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal OpenGL states so that the target is ready for drawing.  <a href="#aac7504990d27dada4bfe3c7866920765"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#af530274b34159d644e509b4b4dc43eb7">initialize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the common initialization step after creation.  <a href="#af530274b34159d644e509b4b4dc43eb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a3ed439c5445e9c7d7ff786ff37005efa">applyCurrentView</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the current view.  <a href="#a3ed439c5445e9c7d7ff786ff37005efa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#aefd4b1cc8e264598b94bd70aaac5bc99">applyBlendMode</a> (<a class="el" href="group__graphics.htm#ga80c52fe2f7050d7f7573b7ed3c995388">BlendMode</a> mode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a new blending mode.  <a href="#aefd4b1cc8e264598b94bd70aaac5bc99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a0b23bd7c287d0fc12b0521b649a0a0e0">applyTransform</a> (const <a class="el" href="classsf_1_1Transform.htm">Transform</a> &amp;transform)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a new transform.  <a href="#a0b23bd7c287d0fc12b0521b649a0a0e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#afb8a49305171aad158a27e0dfbb03709">applyTexture</a> (const <a class="el" href="classsf_1_1Texture.htm">Texture</a> *texture)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a new texture.  <a href="#afb8a49305171aad158a27e0dfbb03709"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a6f8bc92f07c70ccd57cbf632fe9de0ba">applyShader</a> (const <a class="el" href="classsf_1_1Shader.htm">Shader</a> *shader)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a new shader.  <a href="#a6f8bc92f07c70ccd57cbf632fe9de0ba"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Target for off-screen 2D rendering into an texture. </p>
<p><a class="el" href="classsf_1_1RenderTexture.htm" title="Target for off-screen 2D rendering into an texture.">sf::RenderTexture</a> is the little brother of <a class="el" href="classsf_1_1RenderWindow.htm" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a>.</p>
<p>It implements the same 2D drawing and OpenGL-related functions (see their base class <a class="el" href="classsf_1_1RenderTarget.htm" title="Base class for all render targets (window, texture, ...)">sf::RenderTarget</a> for more details), the difference is that the result is stored in an off-screen texture rather than being show in a window.</p>
<p>Rendering to a texture can be useful in a variety of situations: </p>
<ul>
<li>precomputing a complex static texture (like a level's background from multiple tiles) </li>
<li>applying post-effects to the whole scene with shaders </li>
<li>creating a sprite from a 3D object rendered with OpenGL </li>
<li>etc.</li>
</ul>
<p>Usage example:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Create a new render-window</span>
 <a class="code" href="classsf_1_1RenderWindow.htm" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a> window(<a class="code" href="classsf_1_1VideoMode.htm" title="VideoMode defines a video mode (width, height, bpp)">sf::VideoMode</a>(800, 600), <span class="stringliteral">&quot;SFML window&quot;</span>);

 <span class="comment">// Create a new render-texture</span>
 <a class="code" href="classsf_1_1RenderTexture.htm" title="Target for off-screen 2D rendering into an texture.">sf::RenderTexture</a> texture;
 <span class="keywordflow">if</span> (!texture.<a class="code" href="classsf_1_1RenderTexture.htm#aefbb76eb3b87e368ab974b2660931ccb" title="Create the render-texture.">create</a>(500, 500))
     <span class="keywordflow">return</span> -1

 <span class="comment">// The main loop</span>
 <span class="keywordflow">while</span> (window.isOpen())
 {
    <span class="comment">// Event processing</span>
    <span class="comment">// ...</span>

    <span class="comment">// Clear the whole texture with red color</span>
    texture.<a class="code" href="classsf_1_1RenderTarget.htm#a6bb6f0ba348f2b1e2f46114aeaf60f26" title="Clear the entire target with a single color.">clear</a>(<a class="code" href="classsf_1_1Color.htm#a127dbf55db9c07d0fa8f4bfcbb97594a" title="Red predefined color.">sf::Color::Red</a>);

    <span class="comment">// Draw stuff to the texture</span>
    texture.<a class="code" href="classsf_1_1RenderTarget.htm#a12417a3bcc245c41d957b29583556f39" title="Draw a drawable object to the render-target.">draw</a>(sprite);  <span class="comment">// sprite is a sf::Sprite</span>
    texture.<a class="code" href="classsf_1_1RenderTarget.htm#a12417a3bcc245c41d957b29583556f39" title="Draw a drawable object to the render-target.">draw</a>(shape);   <span class="comment">// shape is a sf::Shape</span>
    texture.<a class="code" href="classsf_1_1RenderTarget.htm#a12417a3bcc245c41d957b29583556f39" title="Draw a drawable object to the render-target.">draw</a>(text);    <span class="comment">// text is a sf::Text</span>

    <span class="comment">// We&#39;re done drawing to the texture</span>
    texture.<a class="code" href="classsf_1_1RenderTexture.htm#af92886d5faef3916caff9fa9ab32c555" title="Update the contents of the target texture.">display</a>();

    <span class="comment">// Now we start rendering to the window, clear it first</span>
    window.clear();

    <span class="comment">// Draw the texture</span>
    <a class="code" href="classsf_1_1Sprite.htm" title="Drawable representation of a texture, with its own transformations, color, etc.">sf::Sprite</a> sprite(texture.<a class="code" href="classsf_1_1RenderTexture.htm#a95bc5152c497066d31fdc57da8e17678" title="Get a read-only reference to the target texture.">getTexture</a>());
    window.draw(sprite);

    <span class="comment">// End the current frame and display its contents on screen</span>
    window.display();
 }
</pre></div><p>Like <a class="el" href="classsf_1_1RenderWindow.htm" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a>, <a class="el" href="classsf_1_1RenderTexture.htm" title="Target for off-screen 2D rendering into an texture.">sf::RenderTexture</a> is still able to render direct OpenGL stuff. It is even possible to mix together OpenGL calls and regular SFML drawing commands. If you need a depth buffer for 3D rendering, don't forget to request it when calling RenderTexture::Create.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTarget.htm" title="Base class for all render targets (window, texture, ...)">sf::RenderTarget</a>, <a class="el" href="classsf_1_1RenderWindow.htm" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a>, <a class="el" href="classsf_1_1View.htm" title="2D camera that defines what region is shown on screen">sf::View</a>, <a class="el" href="classsf_1_1Texture.htm" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> </dd></dl>

<p>Definition at line <a class="el" href="RenderTexture_8hpp_source.htm#l00047">47</a> of file <a class="el" href="RenderTexture_8hpp_source.htm">RenderTexture.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a19ee6e5b4c40ad251803389b3953a9c6"></a><!-- doxytag: member="sf::RenderTexture::RenderTexture" ref="a19ee6e5b4c40ad251803389b3953a9c6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1RenderTexture.htm#a19ee6e5b4c40ad251803389b3953a9c6">sf::RenderTexture::RenderTexture</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an empty, invalid render-texture. You must call create to have a valid render-texture.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTexture.htm#aefbb76eb3b87e368ab974b2660931ccb" title="Create the render-texture.">create</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a94b84ab9335be84d2a014c964d973304"></a><!-- doxytag: member="sf::RenderTexture::~RenderTexture" ref="a94b84ab9335be84d2a014c964d973304" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsf_1_1RenderTexture.htm#a94b84ab9335be84d2a014c964d973304">sf::RenderTexture::~RenderTexture</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aefd4b1cc8e264598b94bd70aaac5bc99"></a><!-- doxytag: member="sf::RenderTexture::applyBlendMode" ref="aefd4b1cc8e264598b94bd70aaac5bc99" args="(BlendMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#aefd4b1cc8e264598b94bd70aaac5bc99">sf::RenderTarget::applyBlendMode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__graphics.htm#ga80c52fe2f7050d7f7573b7ed3c995388">BlendMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a new blending mode. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Blending mode to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ed439c5445e9c7d7ff786ff37005efa"></a><!-- doxytag: member="sf::RenderTexture::applyCurrentView" ref="a3ed439c5445e9c7d7ff786ff37005efa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a3ed439c5445e9c7d7ff786ff37005efa">sf::RenderTarget::applyCurrentView</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply the current view. </p>

</div>
</div>
<a class="anchor" id="a6f8bc92f07c70ccd57cbf632fe9de0ba"></a><!-- doxytag: member="sf::RenderTexture::applyShader" ref="a6f8bc92f07c70ccd57cbf632fe9de0ba" args="(const Shader *shader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a6f8bc92f07c70ccd57cbf632fe9de0ba">sf::RenderTarget::applyShader</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Shader.htm">Shader</a> *&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a new shader. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td><a class="el" href="classsf_1_1Shader.htm" title="Shader class (vertex and fragment)">Shader</a> to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb8a49305171aad158a27e0dfbb03709"></a><!-- doxytag: member="sf::RenderTexture::applyTexture" ref="afb8a49305171aad158a27e0dfbb03709" args="(const Texture *texture)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#afb8a49305171aad158a27e0dfbb03709">sf::RenderTarget::applyTexture</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Texture.htm">Texture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a new texture. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="classsf_1_1Texture.htm" title="Image living on the graphics card that can be used for drawing.">Texture</a> to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b23bd7c287d0fc12b0521b649a0a0e0"></a><!-- doxytag: member="sf::RenderTexture::applyTransform" ref="a0b23bd7c287d0fc12b0521b649a0a0e0" args="(const Transform &amp;transform)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a0b23bd7c287d0fc12b0521b649a0a0e0">sf::RenderTarget::applyTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Transform.htm">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a new transform. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td><a class="el" href="classsf_1_1Transform.htm" title="Define a 3x3 transform matrix.">Transform</a> to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6bb6f0ba348f2b1e2f46114aeaf60f26"></a><!-- doxytag: member="sf::RenderTexture::clear" ref="a6bb6f0ba348f2b1e2f46114aeaf60f26" args="(const Color &amp;color=Color(0, 0, 0, 255))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a6bb6f0ba348f2b1e2f46114aeaf60f26">sf::RenderTarget::clear</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Color.htm">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classsf_1_1Color.htm">Color</a>(0,&#160;0,&#160;0,&#160;255)</code></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the entire target with a single color. </p>
<p>This function is usually called once every frame, to clear the previous contents of the target.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Fill color to use to clear the render target </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc047333937f7cb7fe557aec60239233"></a><!-- doxytag: member="sf::RenderTexture::convertCoords" ref="afc047333937f7cb7fe557aec60239233" args="(const Vector2i &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2f</a> <a class="el" href="classsf_1_1RenderTarget.htm#afc047333937f7cb7fe557aec60239233">sf::RenderTarget::convertCoords</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Vector2.htm">Vector2i</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a point from target coordinates to view coordinates. </p>
<p>Initially, a unit of the 2D world matches a pixel of the render target. But if you define a custom view, this assertion is not true anymore, ie. a point located at (10, 50) in your render target (for example a window) may map to the point (150, 75) in your 2D world -- for example if the view is translated by (140, 25).</p>
<p>For render windows, this function is typically used to find which point (or object) is located below the mouse cursor.</p>
<p>This version uses the current view of the render target. See the other overload to specify a custom view.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point to convert, relative to the render target</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The converted point, in "world" units </dd></dl>

</div>
</div>
<a class="anchor" id="ae5e7ba65ef73df2778b29b7fdcdb20ee"></a><!-- doxytag: member="sf::RenderTexture::convertCoords" ref="ae5e7ba65ef73df2778b29b7fdcdb20ee" args="(const Vector2i &amp;point, const View &amp;view) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2f</a> <a class="el" href="classsf_1_1RenderTarget.htm#afc047333937f7cb7fe557aec60239233">sf::RenderTarget::convertCoords</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Vector2.htm">Vector2i</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.htm">View</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a point from target coordinates to view coordinates. </p>
<p>Initially, a unit of the 2D world matches a pixel of the render target. But if you define a custom view, this assertion is not true anymore, ie. a point located at (10, 50) in your render target (for example a window) may map to the point (150, 75) in your 2D world -- for example if the view is translated by (140, 25).</p>
<p>For render windows, this function is typically used to find which point (or object) is located below the mouse cursor.</p>
<p>This version uses a custom view for calculations, see the other overload of the function to use the current view of the render target.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point to convert, relative to the render target </td></tr>
    <tr><td class="paramname">view</td><td>The view to use for converting the point</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The converted point, in "world" units </dd></dl>

</div>
</div>
<a class="anchor" id="aefbb76eb3b87e368ab974b2660931ccb"></a><!-- doxytag: member="sf::RenderTexture::create" ref="aefbb76eb3b87e368ab974b2660931ccb" args="(unsigned int width, unsigned int height, bool depthBuffer=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1RenderTexture.htm#aefbb76eb3b87e368ab974b2660931ccb">sf::RenderTexture::create</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>depthBuffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create the render-texture. </p>
<p>Before calling this function, the render-texture is in an invalid state, thus it is mandatory to call it before doing anything with the render-texture. The last parameter, <em>depthBuffer</em>, is useful if you want to use the render-texture for 3D OpenGL rendering that requires a depth-buffer. Otherwise it is unnecessary, and you should leave this parameter to false (which is its default value).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Width of the render-texture </td></tr>
    <tr><td class="paramname">height</td><td>Height of the render-texture </td></tr>
    <tr><td class="paramname">depthBuffer</td><td>Do you want this render-texture to have a depth buffer?</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if creation has been successful </dd></dl>

</div>
</div>
<a class="anchor" id="af92886d5faef3916caff9fa9ab32c555"></a><!-- doxytag: member="sf::RenderTexture::display" ref="af92886d5faef3916caff9fa9ab32c555" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTexture.htm#af92886d5faef3916caff9fa9ab32c555">sf::RenderTexture::display</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the contents of the target texture. </p>
<p>This function updates the target texture with what has been drawn so far. Like for windows, calling this function is mandatory at the end of rendering. Not calling it may leave the texture in an undefined state. </p>

</div>
</div>
<a class="anchor" id="a12417a3bcc245c41d957b29583556f39"></a><!-- doxytag: member="sf::RenderTexture::draw" ref="a12417a3bcc245c41d957b29583556f39" args="(const Drawable &amp;drawable, const RenderStates &amp;states=RenderStates::Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a12417a3bcc245c41d957b29583556f39">sf::RenderTarget::draw</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Drawable.htm">Drawable</a> &amp;&#160;</td>
          <td class="paramname"><em>drawable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1RenderStates.htm">RenderStates</a> &amp;&#160;</td>
          <td class="paramname"><em>states</em> = <code><a class="el" href="classsf_1_1RenderStates.htm#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a drawable object to the render-target. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">drawable</td><td>Object to draw </td></tr>
    <tr><td class="paramname">states</td><td>Render states to use for drawing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab636d7363f6681077361ee274ba89a8d"></a><!-- doxytag: member="sf::RenderTexture::draw" ref="ab636d7363f6681077361ee274ba89a8d" args="(const Vertex *vertices, unsigned int vertexCount, PrimitiveType type, const RenderStates &amp;states=RenderStates::Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a12417a3bcc245c41d957b29583556f39">sf::RenderTarget::draw</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Vertex.htm">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graphics.htm#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1RenderStates.htm">RenderStates</a> &amp;&#160;</td>
          <td class="paramname"><em>states</em> = <code><a class="el" href="classsf_1_1RenderStates.htm#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw primitives defined by an array of vertices. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to the vertices </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Number of vertices in the array </td></tr>
    <tr><td class="paramname">type</td><td>Type of primitives to draw </td></tr>
    <tr><td class="paramname">states</td><td>Render states to use for drawing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a718b1aa6296bf855171699cc18251ced"></a><!-- doxytag: member="sf::RenderTexture::getDefaultView" ref="a718b1aa6296bf855171699cc18251ced" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsf_1_1View.htm">View</a>&amp; <a class="el" href="classsf_1_1RenderTarget.htm#a718b1aa6296bf855171699cc18251ced">sf::RenderTarget::getDefaultView</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the default view of the render target. </p>
<p>The default view has the initial size of the render target, and never changes after the target has been created.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The default view of the render target</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTarget.htm#a063db6dd0a14913504af30e50cb6d946" title="Change the current active view.">setView</a>, <a class="el" href="classsf_1_1RenderTarget.htm#a98f721cc6dc11478922427fedfb2288b" title="Get the view currently in use in the render target.">getView</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a757ba45ec7a7deefcaef717049b00b8c"></a><!-- doxytag: member="sf::RenderTexture::getSize" ref="a757ba45ec7a7deefcaef717049b00b8c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsf_1_1Vector2.htm">Vector2u</a> <a class="el" href="classsf_1_1RenderTexture.htm#a757ba45ec7a7deefcaef717049b00b8c">sf::RenderTexture::getSize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the size of the rendering region of the texture. </p>
<p>The returned value is the size that you passed to the create function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Size in pixels </dd></dl>

<p>Implements <a class="el" href="classsf_1_1RenderTarget.htm#a2e5ade2457d9fb4c4907ae5b3d9e94a5">sf::RenderTarget</a>.</p>

</div>
</div>
<a class="anchor" id="a95bc5152c497066d31fdc57da8e17678"></a><!-- doxytag: member="sf::RenderTexture::getTexture" ref="a95bc5152c497066d31fdc57da8e17678" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsf_1_1Texture.htm">Texture</a>&amp; <a class="el" href="classsf_1_1RenderTexture.htm#a95bc5152c497066d31fdc57da8e17678">sf::RenderTexture::getTexture</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a read-only reference to the target texture. </p>
<p>After drawing to the render-texture and calling Display, you can retrieve the updated texture using this function, and draw it using a sprite (for example). The internal <a class="el" href="classsf_1_1Texture.htm" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> of a render-texture is always the same instance, so that it is possible to call this function once and keep a reference to the texture even after it is modified.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Const reference to the texture </dd></dl>

</div>
</div>
<a class="anchor" id="a98f721cc6dc11478922427fedfb2288b"></a><!-- doxytag: member="sf::RenderTexture::getView" ref="a98f721cc6dc11478922427fedfb2288b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsf_1_1View.htm">View</a>&amp; <a class="el" href="classsf_1_1RenderTarget.htm#a98f721cc6dc11478922427fedfb2288b">sf::RenderTarget::getView</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the view currently in use in the render target. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The view object that is currently used</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTarget.htm#a063db6dd0a14913504af30e50cb6d946" title="Change the current active view.">setView</a>, <a class="el" href="classsf_1_1RenderTarget.htm#a718b1aa6296bf855171699cc18251ced" title="Get the default view of the render target.">getDefaultView</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aae035b0d45f87a0da2a28a0de6ba1086"></a><!-- doxytag: member="sf::RenderTexture::getViewport" ref="aae035b0d45f87a0da2a28a0de6ba1086" args="(const View &amp;view) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Rect.htm">IntRect</a> <a class="el" href="classsf_1_1RenderTarget.htm#aae035b0d45f87a0da2a28a0de6ba1086">sf::RenderTarget::getViewport</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.htm">View</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the viewport of a view, applied to this render target. </p>
<p>The viewport is defined in the view as a ratio, this function simply applies this ratio to the current dimensions of the render target to calculate the pixels rectangle that the viewport actually covers in the target.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>The view for which we want to compute the viewport</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Viewport rectangle, expressed in pixels </dd></dl>

</div>
</div>
<a class="anchor" id="af530274b34159d644e509b4b4dc43eb7"></a><!-- doxytag: member="sf::RenderTexture::initialize" ref="af530274b34159d644e509b4b4dc43eb7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#af530274b34159d644e509b4b4dc43eb7">sf::RenderTarget::initialize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the common initialization step after creation. </p>
<p>The derived classes must call this function after the target is created and ready for drawing. </p>

</div>
</div>
<a class="anchor" id="ae385f4f4dbd2af50fb11947bf0bcb83d"></a><!-- doxytag: member="sf::RenderTexture::isSmooth" ref="ae385f4f4dbd2af50fb11947bf0bcb83d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1RenderTexture.htm#ae385f4f4dbd2af50fb11947bf0bcb83d">sf::RenderTexture::isSmooth</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell whether the smooth filtering is enabled or not. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if texture smoothing is enabled</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTexture.htm#af08991e63c6020865dd07b20e27305b6" title="Enable or disable texture smoothing.">setSmooth</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad5a98401113df931ddcd54c080f7aa8e"></a><!-- doxytag: member="sf::RenderTexture::popGLStates" ref="ad5a98401113df931ddcd54c080f7aa8e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#ad5a98401113df931ddcd54c080f7aa8e">sf::RenderTarget::popGLStates</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restore the previously saved OpenGL render states and matrices. </p>
<p>See the description of pushGLStates to get a detailed description of these functions.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTarget.htm#a8d1998464ccc54e789aaf990242b47f7" title="Save the current OpenGL render states and matrices.">pushGLStates</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8d1998464ccc54e789aaf990242b47f7"></a><!-- doxytag: member="sf::RenderTexture::pushGLStates" ref="a8d1998464ccc54e789aaf990242b47f7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a8d1998464ccc54e789aaf990242b47f7">sf::RenderTarget::pushGLStates</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save the current OpenGL render states and matrices. </p>
<p>This function can be used when you mix SFML drawing and direct OpenGL rendering. Combined with PopGLStates, it ensures that: </p>
<ul>
<li>SFML's internal states are not messed up by your OpenGL code </li>
<li>your OpenGL states are not modified by a call to a SFML function</li>
</ul>
<p>More specifically, it must be used around code that calls Draw functions. Example: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// OpenGL code here...</span>
 window.pushGLStates();
 window.draw(...);
 window.draw(...);
 window.popGLStates();
 <span class="comment">// OpenGL code here...</span>
</pre></div><p>Note that this function is quite expensive: it saves all the possible OpenGL states and matrices, even the ones you don't care about. Therefore it should be used wisely. It is provided for convenience, but the best results will be achieved if you handle OpenGL states yourself (because you know which states have really changed, and need to be saved and restored). Take a look at the ResetGLStates function if you do so.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTarget.htm#ad5a98401113df931ddcd54c080f7aa8e" title="Restore the previously saved OpenGL render states and matrices.">popGLStates</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aac7504990d27dada4bfe3c7866920765"></a><!-- doxytag: member="sf::RenderTexture::resetGLStates" ref="aac7504990d27dada4bfe3c7866920765" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#aac7504990d27dada4bfe3c7866920765">sf::RenderTarget::resetGLStates</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the internal OpenGL states so that the target is ready for drawing. </p>
<p>This function can be used when you mix SFML drawing and direct OpenGL rendering, if you choose not to use pushGLStates/popGLStates. It makes sure that all OpenGL states needed by SFML are set, so that subsequent <a class="el" href="classsf_1_1RenderTarget.htm#a12417a3bcc245c41d957b29583556f39" title="Draw a drawable object to the render-target.">draw()</a> calls will work as expected.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// OpenGL code here...</span>
 glPushAttrib(...);
 window.resetGLStates();
 window.draw(...);
 window.draw(...);
 glPopAttrib(...);
 <span class="comment">// OpenGL code here...</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="a5da95ecdbce615a80bb78399012508cf"></a><!-- doxytag: member="sf::RenderTexture::setActive" ref="a5da95ecdbce615a80bb78399012508cf" args="(bool active=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1RenderTexture.htm#a5da95ecdbce615a80bb78399012508cf">sf::RenderTexture::setActive</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Activate of deactivate the render-texture for rendering. </p>
<p>This function makes the render-texture's context current for future OpenGL rendering operations (so you shouldn't care about it if you're not doing direct OpenGL stuff). Only one context can be current in a thread, so if you want to draw OpenGL geometry to another render target (like a <a class="el" href="classsf_1_1RenderWindow.htm" title="Window that can serve as a target for 2D drawing.">RenderWindow</a>) don't forget to activate it again.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>True to activate, false to deactivate</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if operation was successful, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="af08991e63c6020865dd07b20e27305b6"></a><!-- doxytag: member="sf::RenderTexture::setSmooth" ref="af08991e63c6020865dd07b20e27305b6" args="(bool smooth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTexture.htm#af08991e63c6020865dd07b20e27305b6">sf::RenderTexture::setSmooth</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smooth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable texture smoothing. </p>
<p>This function is similar to <a class="el" href="classsf_1_1Texture.htm#a0c3bd6825b9a99714f10d44179d74324" title="Enable or disable the smooth filter.">Texture::setSmooth</a>. This parameter is disabled by default.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">smooth</td><td>True to enable smoothing, false to disable it</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTexture.htm#ae385f4f4dbd2af50fb11947bf0bcb83d" title="Tell whether the smooth filtering is enabled or not.">isSmooth</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a063db6dd0a14913504af30e50cb6d946"></a><!-- doxytag: member="sf::RenderTexture::setView" ref="a063db6dd0a14913504af30e50cb6d946" args="(const View &amp;view)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a063db6dd0a14913504af30e50cb6d946">sf::RenderTarget::setView</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.htm">View</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the current active view. </p>
<p>The view is like a 2D camera, it controls which part of the 2D scene is visible, and how it is viewed in the render-target. The new view will affect everything that is drawn, until another view is set. The render target keeps its own copy of the view object, so it is not necessary to keep the original one alive after calling this function. To restore the original view of the target, you can pass the result of <a class="el" href="classsf_1_1RenderTarget.htm#a718b1aa6296bf855171699cc18251ced" title="Get the default view of the render target.">getDefaultView()</a> to this function.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>New view to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTarget.htm#a98f721cc6dc11478922427fedfb2288b" title="Get the view currently in use in the render target.">getView</a>, <a class="el" href="classsf_1_1RenderTarget.htm#a718b1aa6296bf855171699cc18251ced" title="Get the default view of the render target.">getDefaultView</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="RenderTexture_8hpp_source.htm">RenderTexture.hpp</a></li>
</ul>
</div><!-- contents -->

        <p id="footer">
            &nbsp;::&nbsp; Copyright &copy; 2007-2008 Laurent Gomila, all rights reserved &nbsp;::&nbsp;
            Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen 1.5.2</a> &nbsp;::&nbsp;
        </p>

    </body>
</html>
