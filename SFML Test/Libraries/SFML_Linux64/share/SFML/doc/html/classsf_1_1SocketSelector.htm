<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>SFML - Simple and Fast Multimedia Library</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="tabs.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div id="logo">
            <img src="./logo.jpg" width="770" height="200" title="SFML home" alt="SFML logo" />
        </div>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.htm"><span>Classes</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.htm"><span>Class&#160;List</span></a></li>
      <li><a href="classes.htm"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.htm"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.htm"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>sf</b>      </li>
      <li class="navelem"><a class="el" href="classsf_1_1SocketSelector.htm">SocketSelector</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">sf::SocketSelector Class Reference<div class="ingroups"><a class="el" href="group__network.htm">Network module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="sf::SocketSelector" -->
<p>Multiplexer that allows to read from multiple sockets.  
 <a href="classsf_1_1SocketSelector.htm#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SocketSelector_8hpp_source.htm">SocketSelector.hpp</a>&gt;</code></p>

<p><a href="classsf_1_1SocketSelector-members.htm">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SocketSelector.htm#a741959c5158aeb1e4457cad47d90f76b">SocketSelector</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a741959c5158aeb1e4457cad47d90f76b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SocketSelector.htm#a50b1b955eb7ecb2e7c2764f3f4722fbf">SocketSelector</a> (const <a class="el" href="classsf_1_1SocketSelector.htm">SocketSelector</a> &amp;copy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a50b1b955eb7ecb2e7c2764f3f4722fbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SocketSelector.htm#a9069cd61208260b8ed9cf233afa1f73d">~SocketSelector</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a9069cd61208260b8ed9cf233afa1f73d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SocketSelector.htm#ade952013232802ff7b9b33668f8d2096">add</a> (<a class="el" href="classsf_1_1Socket.htm">Socket</a> &amp;socket)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new socket to the selector.  <a href="#ade952013232802ff7b9b33668f8d2096"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SocketSelector.htm#a98b6ab693a65b82caa375639232357c1">remove</a> (<a class="el" href="classsf_1_1Socket.htm">Socket</a> &amp;socket)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a socket from the selector.  <a href="#a98b6ab693a65b82caa375639232357c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SocketSelector.htm#a76e650acb0199d4be91e90a493fbc91a">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the sockets stored in the selector.  <a href="#a76e650acb0199d4be91e90a493fbc91a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SocketSelector.htm#a9cfda5475f17925e65889394d70af702">wait</a> (<a class="el" href="classsf_1_1Time.htm">Time</a> timeout=<a class="el" href="classsf_1_1Time.htm#a8db127b632fa8da21550e7282af11fa0">Time::Zero</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until one or more sockets are ready to receive.  <a href="#a9cfda5475f17925e65889394d70af702"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SocketSelector.htm#a8e67b463db05eadb4d356992c896833c">isReady</a> (<a class="el" href="classsf_1_1Socket.htm">Socket</a> &amp;socket) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a socket to know if it is ready to receive data.  <a href="#a8e67b463db05eadb4d356992c896833c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1SocketSelector.htm">SocketSelector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1SocketSelector.htm#ae6395c7a8d29a9ea14939cc5d1ba3a33">operator=</a> (const <a class="el" href="classsf_1_1SocketSelector.htm">SocketSelector</a> &amp;right)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of assignment operator.  <a href="#ae6395c7a8d29a9ea14939cc5d1ba3a33"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Multiplexer that allows to read from multiple sockets. </p>
<p><a class="el" href="classsf_1_1Socket.htm" title="Base class for all the socket types.">Socket</a> selectors provide a way to wait until some data is available on a set of sockets, instead of just one.</p>
<p>This is convenient when you have multiple sockets that may possibly receive data, but you don't know which one will be ready first. In particular, it avoids to use a thread for each socket; with selectors, a single thread can handle all the sockets.</p>
<p>All types of sockets can be used in a selector: </p>
<ul>
<li><a class="el" href="classsf_1_1TcpListener.htm" title="Socket that listens to new TCP connections.">sf::TcpListener</a> </li>
<li><a class="el" href="classsf_1_1TcpSocket.htm" title="Specialized socket using the TCP protocol.">sf::TcpSocket</a> </li>
<li><a class="el" href="classsf_1_1UdpSocket.htm" title="Specialized socket using the UDP protocol.">sf::UdpSocket</a></li>
</ul>
<p>A selector doesn't store its own copies of the sockets (socket classes are not copyable anyway), it simply keeps a reference to the original sockets that you pass to the Add function. Therefore, you can't use the selector as a socket container, you must store them oustide and make sure that they are alive as long as they are used in the selector.</p>
<p>Using a selector is simple: </p>
<ul>
<li>populate the selector with all the sockets that you want to observe </li>
<li>make it wait until there is data available on any of the sockets </li>
<li>test each socket to find out which ones are ready</li>
</ul>
<p>Usage example: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Create a socket to listen to new connections</span>
 <a class="code" href="classsf_1_1TcpListener.htm" title="Socket that listens to new TCP connections.">sf::TcpListener</a> listener;
 listener.<a class="code" href="classsf_1_1TcpListener.htm#a409d9350d3abfea9636df8cf4a61004e" title="Start listening for connections.">listen</a>(55001);

 <span class="comment">// Create a list to store the future clients</span>
 std::list&lt;sf::TcpSocket*&gt; clients;

 <span class="comment">// Create a selector</span>
 <a class="code" href="classsf_1_1SocketSelector.htm" title="Multiplexer that allows to read from multiple sockets.">sf::SocketSelector</a> selector;

 <span class="comment">// Add the listener to the selector</span>
 selector.<a class="code" href="classsf_1_1SocketSelector.htm#ade952013232802ff7b9b33668f8d2096" title="Add a new socket to the selector.">add</a>(listener);

 <span class="comment">// Endless loop that waits for new connections</span>
 <span class="keywordflow">while</span> (running)
 {
     <span class="comment">// Make the selector wait for data on any socket</span>
     <span class="keywordflow">if</span> (selector.<a class="code" href="classsf_1_1SocketSelector.htm#a9cfda5475f17925e65889394d70af702" title="Wait until one or more sockets are ready to receive.">wait</a>())
     {
         <span class="comment">// Test the listener</span>
         <span class="keywordflow">if</span> (selector.<a class="code" href="classsf_1_1SocketSelector.htm#a8e67b463db05eadb4d356992c896833c" title="Test a socket to know if it is ready to receive data.">isReady</a>(listener))
         {
             <span class="comment">// The listener is ready: there is a pending connection</span>
             <a class="code" href="classsf_1_1TcpSocket.htm" title="Specialized socket using the TCP protocol.">sf::TcpSocket</a>* client = <span class="keyword">new</span> <a class="code" href="classsf_1_1TcpSocket.htm" title="Specialized socket using the TCP protocol.">sf::TcpSocket</a>;
             <span class="keywordflow">if</span> (listener.<a class="code" href="classsf_1_1TcpListener.htm#ae2c83ce5a64d50b68180c46bef0a7346" title="Accept a new connection.">accept</a>(*client) == <a class="code" href="classsf_1_1Socket.htm#a51bf0fd51057b98a10fbb866246176dca1de3a85bc56d3ae85b3d0f3cfd04ae90" title="The socket has sent / received the data.">sf::Socket::Done</a>)
             {
                 <span class="comment">// Add the new client to the clients list</span>
                 clients.push_back(client);

                 <span class="comment">// Add the new client to the selector so that we will</span>
                 <span class="comment">// be notified when he sends something</span>
                 selector.<a class="code" href="classsf_1_1SocketSelector.htm#ade952013232802ff7b9b33668f8d2096" title="Add a new socket to the selector.">add</a>(*client);
             }
         }
         <span class="keywordflow">else</span>
         {
             <span class="comment">// The listener socket is not ready, test all other sockets (the clients)</span>
             <span class="keywordflow">for</span> (std::list&lt;sf::TcpSocket*&gt;::iterator it = clients.begin(); it != clients.end(); ++it)
             {
                 <a class="code" href="classsf_1_1TcpSocket.htm" title="Specialized socket using the TCP protocol.">sf::TcpSocket</a>&amp; client = **it;
                 <span class="keywordflow">if</span> (selector.<a class="code" href="classsf_1_1SocketSelector.htm#a8e67b463db05eadb4d356992c896833c" title="Test a socket to know if it is ready to receive data.">isReady</a>(client))
                 {
                     <span class="comment">// The client has sent some data, we can receive it</span>
                     <a class="code" href="classsf_1_1Packet.htm" title="Utility class to build blocks of data to transfer over the network.">sf::Packet</a> packet;
                     <span class="keywordflow">if</span> (client.<a class="code" href="classsf_1_1TcpSocket.htm#a90ce50811ea61d4f00efc62bb99ae1af" title="Receive raw data from the remote peer.">receive</a>(packet) == <a class="code" href="classsf_1_1Socket.htm#a51bf0fd51057b98a10fbb866246176dca1de3a85bc56d3ae85b3d0f3cfd04ae90" title="The socket has sent / received the data.">sf::Socket::Done</a>)
                     {
                         ...
                     }
                 }
             }
         }
     }
 }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Socket.htm" title="Base class for all the socket types.">sf::Socket</a> </dd></dl>

<p>Definition at line <a class="el" href="SocketSelector_8hpp_source.htm#l00043">43</a> of file <a class="el" href="SocketSelector_8hpp_source.htm">SocketSelector.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a741959c5158aeb1e4457cad47d90f76b"></a><!-- doxytag: member="sf::SocketSelector::SocketSelector" ref="a741959c5158aeb1e4457cad47d90f76b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1SocketSelector.htm#a741959c5158aeb1e4457cad47d90f76b">sf::SocketSelector::SocketSelector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a50b1b955eb7ecb2e7c2764f3f4722fbf"></a><!-- doxytag: member="sf::SocketSelector::SocketSelector" ref="a50b1b955eb7ecb2e7c2764f3f4722fbf" args="(const SocketSelector &amp;copy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1SocketSelector.htm#a741959c5158aeb1e4457cad47d90f76b">sf::SocketSelector::SocketSelector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1SocketSelector.htm">SocketSelector</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>Instance to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9069cd61208260b8ed9cf233afa1f73d"></a><!-- doxytag: member="sf::SocketSelector::~SocketSelector" ref="a9069cd61208260b8ed9cf233afa1f73d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1SocketSelector.htm#a9069cd61208260b8ed9cf233afa1f73d">sf::SocketSelector::~SocketSelector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ade952013232802ff7b9b33668f8d2096"></a><!-- doxytag: member="sf::SocketSelector::add" ref="ade952013232802ff7b9b33668f8d2096" args="(Socket &amp;socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1SocketSelector.htm#ade952013232802ff7b9b33668f8d2096">sf::SocketSelector::add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Socket.htm">Socket</a> &amp;&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new socket to the selector. </p>
<p>This function keeps a weak reference to the socket, so you have to make sure that the socket is not destroyed while it is stored in the selector.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Reference to the socket to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1SocketSelector.htm#a98b6ab693a65b82caa375639232357c1" title="Remove a socket from the selector.">remove</a>, <a class="el" href="classsf_1_1SocketSelector.htm#a76e650acb0199d4be91e90a493fbc91a" title="Remove all the sockets stored in the selector.">clear</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a76e650acb0199d4be91e90a493fbc91a"></a><!-- doxytag: member="sf::SocketSelector::clear" ref="a76e650acb0199d4be91e90a493fbc91a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1SocketSelector.htm#a76e650acb0199d4be91e90a493fbc91a">sf::SocketSelector::clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove all the sockets stored in the selector. </p>
<p>This function doesn't destroy any instance, it simply removes all the references that the selector has to external sockets.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1SocketSelector.htm#ade952013232802ff7b9b33668f8d2096" title="Add a new socket to the selector.">add</a>, <a class="el" href="classsf_1_1SocketSelector.htm#a98b6ab693a65b82caa375639232357c1" title="Remove a socket from the selector.">remove</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8e67b463db05eadb4d356992c896833c"></a><!-- doxytag: member="sf::SocketSelector::isReady" ref="a8e67b463db05eadb4d356992c896833c" args="(Socket &amp;socket) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1SocketSelector.htm#a8e67b463db05eadb4d356992c896833c">sf::SocketSelector::isReady</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Socket.htm">Socket</a> &amp;&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test a socket to know if it is ready to receive data. </p>
<p>This function must be used after a call to Wait, to know which sockets are ready to receive data. If a socket is ready, a call to receive will never block because we know that there is data available to read. Note that if this function returns true for a <a class="el" href="classsf_1_1TcpListener.htm" title="Socket that listens to new TCP connections.">TcpListener</a>, this means that it is ready to accept a new connection.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td><a class="el" href="classsf_1_1Socket.htm" title="Base class for all the socket types.">Socket</a> to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the socket is ready to read, false otherwise</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1SocketSelector.htm#a8e67b463db05eadb4d356992c896833c" title="Test a socket to know if it is ready to receive data.">isReady</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae6395c7a8d29a9ea14939cc5d1ba3a33"></a><!-- doxytag: member="sf::SocketSelector::operator=" ref="ae6395c7a8d29a9ea14939cc5d1ba3a33" args="(const SocketSelector &amp;right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1SocketSelector.htm">SocketSelector</a>&amp; sf::SocketSelector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1SocketSelector.htm">SocketSelector</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of assignment operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>Instance to assign</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a98b6ab693a65b82caa375639232357c1"></a><!-- doxytag: member="sf::SocketSelector::remove" ref="a98b6ab693a65b82caa375639232357c1" args="(Socket &amp;socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1SocketSelector.htm#a98b6ab693a65b82caa375639232357c1">sf::SocketSelector::remove</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Socket.htm">Socket</a> &amp;&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a socket from the selector. </p>
<p>This function doesn't destroy the socket, it simply removes the reference that the selector has to it.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Reference to the socket to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1SocketSelector.htm#ade952013232802ff7b9b33668f8d2096" title="Add a new socket to the selector.">add</a>, <a class="el" href="classsf_1_1SocketSelector.htm#a76e650acb0199d4be91e90a493fbc91a" title="Remove all the sockets stored in the selector.">clear</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9cfda5475f17925e65889394d70af702"></a><!-- doxytag: member="sf::SocketSelector::wait" ref="a9cfda5475f17925e65889394d70af702" args="(Time timeout=Time::Zero)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1SocketSelector.htm#a9cfda5475f17925e65889394d70af702">sf::SocketSelector::wait</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Time.htm">Time</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="classsf_1_1Time.htm#a8db127b632fa8da21550e7282af11fa0">Time::Zero</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait until one or more sockets are ready to receive. </p>
<p>This function returns as soon as at least one socket has some data available to be received. To know which sockets are ready, use the isReady function. If you use a timeout and no socket is ready before the timeout is over, the function returns false.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Maximum time to wait, (use <a class="el" href="classsf_1_1Time.htm#a8db127b632fa8da21550e7282af11fa0" title="Predefined &quot;zero&quot; time value.">Time::Zero</a> for infinity)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if there are sockets ready, false otherwise</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1SocketSelector.htm#a8e67b463db05eadb4d356992c896833c" title="Test a socket to know if it is ready to receive data.">isReady</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SocketSelector_8hpp_source.htm">SocketSelector.hpp</a></li>
</ul>
</div><!-- contents -->

        <p id="footer">
            &nbsp;::&nbsp; Copyright &copy; 2007-2008 Laurent Gomila, all rights reserved &nbsp;::&nbsp;
            Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen 1.5.2</a> &nbsp;::&nbsp;
        </p>

    </body>
</html>
