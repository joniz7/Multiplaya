<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>SFML - Simple and Fast Multimedia Library</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="tabs.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div id="logo">
            <img src="./logo.jpg" width="770" height="200" title="SFML home" alt="SFML logo" />
        </div>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.htm"><span>Classes</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.htm"><span>Class&#160;List</span></a></li>
      <li><a href="classes.htm"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.htm"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.htm"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>sf</b>      </li>
      <li class="navelem"><a class="el" href="classsf_1_1Packet.htm">Packet</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">sf::Packet Class Reference<div class="ingroups"><a class="el" href="group__network.htm">Network module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="sf::Packet" -->
<p>Utility class to build blocks of data to transfer over the network.  
 <a href="classsf_1_1Packet.htm#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Packet_8hpp_source.htm">Packet.hpp</a>&gt;</code></p>

<p><a href="classsf_1_1Packet-members.htm">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm#a786e5d4ced83992ceefa1799963ea858">Packet</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a786e5d4ced83992ceefa1799963ea858"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm#adc0490ca3c7c3d1e321bd742e5213913">~Packet</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="#adc0490ca3c7c3d1e321bd742e5213913"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm#a7dd6e429b87520008326c4d71f1cf011">append</a> (const void *data, std::size_t sizeInBytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append data to the end of the packet.  <a href="#a7dd6e429b87520008326c4d71f1cf011"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm#a133ea8b8fe6e93c230f0d79f19a3bf0d">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the packet.  <a href="#a133ea8b8fe6e93c230f0d79f19a3bf0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm#a304ba9ec94c992710f4dfff879c6340e">getData</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data contained in the packet.  <a href="#a304ba9ec94c992710f4dfff879c6340e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm#a004b62aa5bafa69df8917171a3fe1fa0">getDataSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the data contained in the packet.  <a href="#a004b62aa5bafa69df8917171a3fe1fa0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm#aee3adfca6303f1e6bde3c62be392b945">endOfPacket</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the reading position has reached the end of the packet.  <a href="#aee3adfca6303f1e6bde3c62be392b945"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm#addcb990cde37859c748273d9de55e628">operator BoolType</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the validity of the packet, for reading.  <a href="#addcb990cde37859c748273d9de55e628"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm#af8e26c63ba9bdccd262565ff0d3eeba2">operator&gt;&gt;</a> (bool &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads of operator &gt;&gt; to read data from the packet.  <a href="#af8e26c63ba9bdccd262565ff0d3eeba2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70fd5abb9095b5335b79c0cefd17b222"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="a70fd5abb9095b5335b79c0cefd17b222" args="(Int8 &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (Int8 &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa67738284a7efc16c7594b358ef35510"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="aa67738284a7efc16c7594b358ef35510" args="(Uint8 &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (Uint8 &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af82d6c4e6d74f2ca39732c1e29f30781"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="af82d6c4e6d74f2ca39732c1e29f30781" args="(Int16 &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (Int16 &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd8706f092bc830ebb438aeee9271647"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="afd8706f092bc830ebb438aeee9271647" args="(Uint16 &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (Uint16 &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7b44e79f12d500b63f5dc2a10d78d8c"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="ae7b44e79f12d500b63f5dc2a10d78d8c" args="(Int32 &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (Int32 &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b57e1953db5bec39a851929df9a339a"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="a4b57e1953db5bec39a851929df9a339a" args="(Uint32 &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (Uint32 &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6704b4d13d6f798efe6fa836a8b5fa24"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="a6704b4d13d6f798efe6fa836a8b5fa24" args="(float &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (float &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac84239a8ba0a165394805c17b35a88cf"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="ac84239a8ba0a165394805c17b35a88cf" args="(double &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (double &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9f8d8b0c776204f79f615b1e58bccec"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="ae9f8d8b0c776204f79f615b1e58bccec" args="(char *data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (char *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabace32063c44e1a5cc54af6267c1fab"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="aabace32063c44e1a5cc54af6267c1fab" args="(std::string &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::string &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1444500d29df0991e630ac78933c6282"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="a1444500d29df0991e630ac78933c6282" args="(wchar_t *data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (wchar_t *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab74c37a290385fd7b1f962bf954a2005"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="ab74c37a290385fd7b1f962bf954a2005" args="(std::wstring &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::wstring &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a081233e0cab2182a219b129a1383dc0b"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="a081233e0cab2182a219b129a1383dc0b" args="(String &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="classsf_1_1String.htm">String</a> &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm#aa5a465ed02ba29d83ecdafb0ac3fff21">operator&lt;&lt;</a> (bool data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads of operator &lt;&lt; to write data into the packet.  <a href="#aa5a465ed02ba29d83ecdafb0ac3fff21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a034b68a4281cae0b53a43af7aa4172f6"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="a034b68a4281cae0b53a43af7aa4172f6" args="(Int8 data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (Int8 data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af27e4498bf83151b0591d5f04a8b30e1"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="af27e4498bf83151b0591d5f04a8b30e1" args="(Uint8 data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (Uint8 data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afda8754ab4f2a34600f0153ba9ff24fa"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="afda8754ab4f2a34600f0153ba9ff24fa" args="(Int16 data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (Int16 data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a557cbc0289135209248aca1aa2117c40"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="a557cbc0289135209248aca1aa2117c40" args="(Uint16 data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (Uint16 data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad60c9ad6e4e92399e2a36938ad122d05"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="ad60c9ad6e4e92399e2a36938ad122d05" args="(Int32 data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (Int32 data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb113b73749efb662a75deb98257ad34"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="afb113b73749efb662a75deb98257ad34" args="(Uint32 data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (Uint32 data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76d31c4f864253a7e9b53701b4660fe5"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="a76d31c4f864253a7e9b53701b4660fe5" args="(float data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (float data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b3077720a486b569ac8e7dec638a3f0"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="a3b3077720a486b569ac8e7dec638a3f0" args="(double data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (double data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67c9985f7b3d6e90886e56e309280a9d"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="a67c9985f7b3d6e90886e56e309280a9d" args="(const char *data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const char *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59a21671caaa69da5d47c54b50e1eb54"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="a59a21671caaa69da5d47c54b50e1eb54" args="(const std::string &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const std::string &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f7c6a9ce795fac342ea937896d98016"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="a6f7c6a9ce795fac342ea937896d98016" args="(const wchar_t *data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const wchar_t *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f3401d038470f629d0c2c6be928a14b"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="a9f3401d038470f629d0c2c6be928a14b" args="(const std::wstring &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const std::wstring &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc17272df082a36b202e10045bd9e220"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="abc17272df082a36b202e10045bd9e220" args="(const String &amp;data)" -->
<a class="el" href="classsf_1_1Packet.htm">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="classsf_1_1String.htm">String</a> &amp;data)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm#a052e955906c9bfd671622cb625380edc">onSend</a> (std::size_t &amp;size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the packet is sent over the network.  <a href="#a052e955906c9bfd671622cb625380edc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Packet.htm#ab71a31ef0f1d5d856de6f9fc75434128">onReceive</a> (const void *data, std::size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the packet is received over the network.  <a href="#ab71a31ef0f1d5d856de6f9fc75434128"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8b32310b01d4bb702d6bcb969d5f130"></a><!-- doxytag: member="sf::Packet::TcpSocket" ref="aa8b32310b01d4bb702d6bcb969d5f130" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>TcpSocket</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae128c6687ced82c6157c5f865f8dec5c"></a><!-- doxytag: member="sf::Packet::UdpSocket" ref="ae128c6687ced82c6157c5f865f8dec5c" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>UdpSocket</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Utility class to build blocks of data to transfer over the network. </p>
<p>Packets provide a safe and easy way to serialize data, in order to send it over the network using sockets (<a class="el" href="classsf_1_1TcpSocket.htm" title="Specialized socket using the TCP protocol.">sf::TcpSocket</a>, <a class="el" href="classsf_1_1UdpSocket.htm" title="Specialized socket using the UDP protocol.">sf::UdpSocket</a>).</p>
<p>Packets solve 2 fundamental problems that arise when transfering data over the network: </p>
<ul>
<li>data is interpreted correctly according to the endianness </li>
<li>the bounds of the packet are preserved (one send == one receive)</li>
</ul>
<p>The <a class="el" href="classsf_1_1Packet.htm" title="Utility class to build blocks of data to transfer over the network.">sf::Packet</a> class provides both input and output modes. It is designed to follow the behaviour of standard C++ streams, using operators &gt;&gt; and &lt;&lt; to extract and insert data.</p>
<p>It is recommended to use only fixed-size types (like sf::Int32, etc.), to avoid possible differences between the sender and the receiver. Indeed, the native C++ types may have different sizes on two platforms and your data may be corrupted if that happens.</p>
<p>Usage example: </p>
<div class="fragment"><pre class="fragment"> sf::Uint32 x = 24;
 std::string s = <span class="stringliteral">&quot;hello&quot;</span>;
 <span class="keywordtype">double</span> d = 5.89;

 <span class="comment">// Group the variables to send into a packet</span>
 <a class="code" href="classsf_1_1Packet.htm" title="Utility class to build blocks of data to transfer over the network.">sf::Packet</a> packet;
 packet &lt;&lt; x &lt;&lt; s &lt;&lt; d;

 <span class="comment">// Send it over the network (socket is a valid sf::TcpSocket)</span>
 socket.send(packet);

 -----------------------------------------------------------------

 <span class="comment">// Receive the packet at the other end</span>
 <a class="code" href="classsf_1_1Packet.htm" title="Utility class to build blocks of data to transfer over the network.">sf::Packet</a> packet;
 socket.receive(packet);

 <span class="comment">// Extract the variables contained in the packet</span>
 sf::Uint32 x;
 std::string s;
 <span class="keywordtype">double</span> d;
 <span class="keywordflow">if</span> (packet &gt;&gt; x &gt;&gt; s &gt;&gt; d)
 {
     <span class="comment">// Data extracted successfully...</span>
 }
</pre></div><p>Packets have built-in operator &gt;&gt; and &lt;&lt; overloads for standard types: </p>
<ul>
<li>bool </li>
<li>fixed-size integer types (sf::Int8/16/32, sf::Uint8/16/32) </li>
<li>floating point numbers (float, double) </li>
<li>string types (char*, wchar_t*, std::string, std::wstring, <a class="el" href="classsf_1_1String.htm" title="Utility string class that automatically handles conversions between types and encodings.">sf::String</a>)</li>
</ul>
<p>Like standard streams, it is also possible to define your own overloads of operators &gt;&gt; and &lt;&lt; in order to handle your custom types.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>MyStruct
 {
     <span class="keywordtype">float</span>       number;
     sf::Int8    integer;
     std::string str;
 };

 <a class="code" href="classsf_1_1Packet.htm" title="Utility class to build blocks of data to transfer over the network.">sf::Packet</a>&amp; <a class="code" href="classsf_1_1Packet.htm#aa5a465ed02ba29d83ecdafb0ac3fff21" title="Overloads of operator &lt;&lt; to write data into the packet.">operator &lt;&lt;</a>(<a class="code" href="classsf_1_1Packet.htm" title="Utility class to build blocks of data to transfer over the network.">sf::Packet</a>&amp; packet, <span class="keyword">const</span> MyStruct&amp; m)
 {
     <span class="keywordflow">return</span> packet &lt;&lt; m.number &lt;&lt; m.integer &lt;&lt; m.str;
 }

 <a class="code" href="classsf_1_1Packet.htm" title="Utility class to build blocks of data to transfer over the network.">sf::Packet</a>&amp; <a class="code" href="classsf_1_1Packet.htm#af8e26c63ba9bdccd262565ff0d3eeba2" title="Overloads of operator &gt;&gt; to read data from the packet.">operator &gt;&gt;</a>(<a class="code" href="classsf_1_1Packet.htm" title="Utility class to build blocks of data to transfer over the network.">sf::Packet</a>&amp; packet, MyStruct&amp; m)
 {
     <span class="keywordflow">return</span> packet &gt;&gt; m.number &gt;&gt; m.integer &gt;&gt; m.str;
 }
</pre></div><p>Packets also provide an extra feature that allows to apply custom transformations to the data before it is sent, and after it is received. This is typically used to handle automatic compression or encryption of the data. This is achieved by inheriting from <a class="el" href="classsf_1_1Packet.htm" title="Utility class to build blocks of data to transfer over the network.">sf::Packet</a>, and overriding the onSend and onReceive functions.</p>
<p>Here is an example: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>ZipPacket : <span class="keyword">public</span> sf::<a class="code" href="classsf_1_1Packet.htm#a786e5d4ced83992ceefa1799963ea858" title="Default constructor.">Packet</a>
 {
     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">void</span>* <a class="code" href="classsf_1_1Packet.htm#a052e955906c9bfd671622cb625380edc" title="Called before the packet is sent over the network.">onSend</a>(std::size_t&amp; size)
     {
         <span class="keyword">const</span> <span class="keywordtype">void</span>* srcData = <a class="code" href="classsf_1_1Packet.htm#a304ba9ec94c992710f4dfff879c6340e" title="Get a pointer to the data contained in the packet.">getData</a>();
         std::size_t srcSize = <a class="code" href="classsf_1_1Packet.htm#a004b62aa5bafa69df8917171a3fe1fa0" title="Get the size of the data contained in the packet.">getDataSize</a>();

         <span class="keywordflow">return</span> MySuperZipFunction(srcData, srcSize, &amp;size);
     }

     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classsf_1_1Packet.htm#ab71a31ef0f1d5d856de6f9fc75434128" title="Called after the packet is received over the network.">onReceive</a>(<span class="keyword">const</span> <span class="keywordtype">void</span>* data, std::size_t size)
     {
         std::size_t dstSize;
         <span class="keyword">const</span> <span class="keywordtype">void</span>* dstData = MySuperUnzipFunction(data, size, &amp;dstSize);

         <a class="code" href="classsf_1_1Packet.htm#a7dd6e429b87520008326c4d71f1cf011" title="Append data to the end of the packet.">append</a>(dstData, dstSize);
     }
 };

 <span class="comment">// Use like regular packets:</span>
 ZipPacket packet;
 packet &lt;&lt; x &lt;&lt; s &lt;&lt; d;
 ...
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1TcpSocket.htm" title="Specialized socket using the TCP protocol.">sf::TcpSocket</a>, <a class="el" href="classsf_1_1UdpSocket.htm" title="Specialized socket using the UDP protocol.">sf::UdpSocket</a> </dd></dl>

<p>Definition at line <a class="el" href="Packet_8hpp_source.htm#l00047">47</a> of file <a class="el" href="Packet_8hpp_source.htm">Packet.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a786e5d4ced83992ceefa1799963ea858"></a><!-- doxytag: member="sf::Packet::Packet" ref="a786e5d4ced83992ceefa1799963ea858" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Packet.htm#a786e5d4ced83992ceefa1799963ea858">sf::Packet::Packet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty packet. </p>

</div>
</div>
<a class="anchor" id="adc0490ca3c7c3d1e321bd742e5213913"></a><!-- doxytag: member="sf::Packet::~Packet" ref="adc0490ca3c7c3d1e321bd742e5213913" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsf_1_1Packet.htm#adc0490ca3c7c3d1e321bd742e5213913">sf::Packet::~Packet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Virtual destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7dd6e429b87520008326c4d71f1cf011"></a><!-- doxytag: member="sf::Packet::append" ref="a7dd6e429b87520008326c4d71f1cf011" args="(const void *data, std::size_t sizeInBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Packet.htm#a7dd6e429b87520008326c4d71f1cf011">sf::Packet::append</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>sizeInBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append data to the end of the packet. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the sequence of bytes to append </td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>Number of bytes to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Packet.htm#a133ea8b8fe6e93c230f0d79f19a3bf0d" title="Clear the packet.">clear</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a133ea8b8fe6e93c230f0d79f19a3bf0d"></a><!-- doxytag: member="sf::Packet::clear" ref="a133ea8b8fe6e93c230f0d79f19a3bf0d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Packet.htm#a133ea8b8fe6e93c230f0d79f19a3bf0d">sf::Packet::clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the packet. </p>
<p>After calling Clear, the packet is empty.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Packet.htm#a7dd6e429b87520008326c4d71f1cf011" title="Append data to the end of the packet.">append</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aee3adfca6303f1e6bde3c62be392b945"></a><!-- doxytag: member="sf::Packet::endOfPacket" ref="aee3adfca6303f1e6bde3c62be392b945" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1Packet.htm#aee3adfca6303f1e6bde3c62be392b945">sf::Packet::endOfPacket</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell if the reading position has reached the end of the packet. </p>
<p>This function is useful to know if there is some data left to be read, without actually reading it.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if all data was read, false otherwise</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator bool </dd></dl>

</div>
</div>
<a class="anchor" id="a304ba9ec94c992710f4dfff879c6340e"></a><!-- doxytag: member="sf::Packet::getData" ref="a304ba9ec94c992710f4dfff879c6340e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* <a class="el" href="classsf_1_1Packet.htm#a304ba9ec94c992710f4dfff879c6340e">sf::Packet::getData</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a pointer to the data contained in the packet. </p>
<p>Warning: the returned pointer may become invalid after you append data to the packet, therefore it should never be stored. The return pointer is NULL if the packet is empty.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the data</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Packet.htm#a004b62aa5bafa69df8917171a3fe1fa0" title="Get the size of the data contained in the packet.">getDataSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a004b62aa5bafa69df8917171a3fe1fa0"></a><!-- doxytag: member="sf::Packet::getDataSize" ref="a004b62aa5bafa69df8917171a3fe1fa0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classsf_1_1Packet.htm#a004b62aa5bafa69df8917171a3fe1fa0">sf::Packet::getDataSize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the size of the data contained in the packet. </p>
<p>This function returns the number of bytes pointed to by what getData returns.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Data size, in bytes</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Packet.htm#a304ba9ec94c992710f4dfff879c6340e" title="Get a pointer to the data contained in the packet.">getData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab71a31ef0f1d5d856de6f9fc75434128"></a><!-- doxytag: member="sf::Packet::onReceive" ref="ab71a31ef0f1d5d856de6f9fc75434128" args="(const void *data, std::size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsf_1_1Packet.htm#ab71a31ef0f1d5d856de6f9fc75434128">sf::Packet::onReceive</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called after the packet is received over the network. </p>
<p>This function can be defined by derived classes to transform the data after it is received; this can be used for uncompression, decryption, etc. The function receives a pointer to the received data, and must fill the packet with the transformed bytes. The default implementation fills the packet directly without transforming the data.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the received bytes </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Packet.htm#a052e955906c9bfd671622cb625380edc" title="Called before the packet is sent over the network.">onSend</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a052e955906c9bfd671622cb625380edc"></a><!-- doxytag: member="sf::Packet::onSend" ref="a052e955906c9bfd671622cb625380edc" args="(std::size_t &amp;size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* <a class="el" href="classsf_1_1Packet.htm#a052e955906c9bfd671622cb625380edc">sf::Packet::onSend</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called before the packet is sent over the network. </p>
<p>This function can be defined by derived classes to transform the data before it is sent; this can be used for compression, encryption, etc. The function must return a pointer to the modified data, as well as the number of bytes pointed. The default implementation provides the packet's data without transforming it.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Variable to fill with the size of data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the array of bytes to send</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Packet.htm#ab71a31ef0f1d5d856de6f9fc75434128" title="Called after the packet is received over the network.">onReceive</a> </dd></dl>

</div>
</div>
<a class="anchor" id="addcb990cde37859c748273d9de55e628"></a><!-- doxytag: member="sf::Packet::operator BoolType" ref="addcb990cde37859c748273d9de55e628" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::Packet::operator BoolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test the validity of the packet, for reading. </p>
<p>This operator allows to test the packet as a boolean variable, to check if a reading operation was successful.</p>
<p>A packet will be in an invalid state if it has no more data to read.</p>
<p>This behaviour is the same as standard C++ streams.</p>
<p>Usage example: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">float</span> x;
 packet &gt;&gt; x;
 <span class="keywordflow">if</span> (packet)
 {
    <span class="comment">// ok, x was extracted successfully</span>
 }

 <span class="comment">// -- or --</span>

 <span class="keywordtype">float</span> x;
 <span class="keywordflow">if</span> (packet &gt;&gt; x)
 {
    <span class="comment">// ok, x was extracted successfully</span>
 }
</pre></div><p>Don't focus on the return type, it's equivalent to bool but it disallows unwanted implicit conversions to integer or pointer types.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if last data extraction from packet was successful</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Packet.htm#aee3adfca6303f1e6bde3c62be392b945" title="Tell if the reading position has reached the end of the packet.">endOfPacket</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5a465ed02ba29d83ecdafb0ac3fff21"></a><!-- doxytag: member="sf::Packet::operator&lt;&lt;" ref="aa5a465ed02ba29d83ecdafb0ac3fff21" args="(bool data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Packet.htm">Packet</a>&amp; sf::Packet::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloads of operator &lt;&lt; to write data into the packet. </p>

</div>
</div>
<a class="anchor" id="af8e26c63ba9bdccd262565ff0d3eeba2"></a><!-- doxytag: member="sf::Packet::operator&gt;&gt;" ref="af8e26c63ba9bdccd262565ff0d3eeba2" args="(bool &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Packet.htm">Packet</a>&amp; sf::Packet::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloads of operator &gt;&gt; to read data from the packet. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Packet_8hpp_source.htm">Packet.hpp</a></li>
</ul>
</div><!-- contents -->

        <p id="footer">
            &nbsp;::&nbsp; Copyright &copy; 2007-2008 Laurent Gomila, all rights reserved &nbsp;::&nbsp;
            Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen 1.5.2</a> &nbsp;::&nbsp;
        </p>

    </body>
</html>
