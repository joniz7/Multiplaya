<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>SFML - Simple and Fast Multimedia Library</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="tabs.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div id="logo">
            <img src="./logo.jpg" width="770" height="200" title="SFML home" alt="SFML logo" />
        </div>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li><a href="annotated.htm"><span>Classes</span></a></li>
      <li class="current"><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.htm"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Utf.inl</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// SFML - Simple and Fast Multimedia Library</span>
<a name="l00004"></a>00004 <span class="comment">// Copyright (C) 2007-2012 Laurent Gomila (laurent.gom@gmail.com)</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">// This software is provided &#39;as-is&#39;, without any express or implied warranty.</span>
<a name="l00007"></a>00007 <span class="comment">// In no event will the authors be held liable for any damages arising from the use of this software.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// Permission is granted to anyone to use this software for any purpose,</span>
<a name="l00010"></a>00010 <span class="comment">// including commercial applications, and to alter it and redistribute it freely,</span>
<a name="l00011"></a>00011 <span class="comment">// subject to the following restrictions:</span>
<a name="l00012"></a>00012 <span class="comment">//</span>
<a name="l00013"></a>00013 <span class="comment">// 1. The origin of this software must not be misrepresented;</span>
<a name="l00014"></a>00014 <span class="comment">//    you must not claim that you wrote the original software.</span>
<a name="l00015"></a>00015 <span class="comment">//    If you use this software in a product, an acknowledgment</span>
<a name="l00016"></a>00016 <span class="comment">//    in the product documentation would be appreciated but is not required.</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment">// 2. Altered source versions must be plainly marked as such,</span>
<a name="l00019"></a>00019 <span class="comment">//    and must not be misrepresented as being the original software.</span>
<a name="l00020"></a>00020 <span class="comment">//</span>
<a name="l00021"></a>00021 <span class="comment">// 3. This notice may not be removed or altered from any source distribution.</span>
<a name="l00022"></a>00022 <span class="comment">//</span>
<a name="l00024"></a>00024 <span class="comment"></span>
<a name="l00025"></a>00025 
<a name="l00027"></a>00027 <span class="comment">// References :</span>
<a name="l00028"></a>00028 <span class="comment">//</span>
<a name="l00029"></a>00029 <span class="comment">// http://www.unicode.org/</span>
<a name="l00030"></a>00030 <span class="comment">// http://www.unicode.org/Public/PROGRAMS/CVTUTF/ConvertUTF.c</span>
<a name="l00031"></a>00031 <span class="comment">// http://www.unicode.org/Public/PROGRAMS/CVTUTF/ConvertUTF.h</span>
<a name="l00032"></a>00032 <span class="comment">// http://people.w3.org/rishida/scripts/uniview/conversion</span>
<a name="l00033"></a>00033 <span class="comment">//</span>
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 
<a name="l00038"></a>00038 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In&gt;
<a name="l00039"></a>00039 In Utf&lt;8&gt;::decode(In begin, In end, Uint32&amp; output, Uint32 replacement)
<a name="l00040"></a>00040 {
<a name="l00041"></a>00041     <span class="comment">// Some useful precomputed data</span>
<a name="l00042"></a>00042     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> trailing[256] =
<a name="l00043"></a>00043     {
<a name="l00044"></a>00044         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<a name="l00045"></a>00045         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<a name="l00046"></a>00046         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<a name="l00047"></a>00047         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<a name="l00048"></a>00048         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<a name="l00049"></a>00049         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<a name="l00050"></a>00050         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<a name="l00051"></a>00051         2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5
<a name="l00052"></a>00052     };
<a name="l00053"></a>00053     <span class="keyword">static</span> <span class="keyword">const</span> Uint32 offsets[6] =
<a name="l00054"></a>00054     {
<a name="l00055"></a>00055         0x00000000, 0x00003080, 0x000E2080, 0x03C82080, 0xFA082080, 0x82082080
<a name="l00056"></a>00056     };
<a name="l00057"></a>00057 
<a name="l00058"></a>00058     <span class="comment">// decode the character</span>
<a name="l00059"></a>00059     <span class="keywordtype">int</span> trailingBytes = trailing[<span class="keyword">static_cast&lt;</span>Uint8<span class="keyword">&gt;</span>(*begin)];
<a name="l00060"></a>00060     <span class="keywordflow">if</span> (begin + trailingBytes &lt; end)
<a name="l00061"></a>00061     {
<a name="l00062"></a>00062         output = 0;
<a name="l00063"></a>00063         <span class="keywordflow">switch</span> (trailingBytes)
<a name="l00064"></a>00064         {
<a name="l00065"></a>00065             <span class="keywordflow">case</span> 5 : output += <span class="keyword">static_cast&lt;</span>Uint8<span class="keyword">&gt;</span>(*begin++); output &lt;&lt;= 6;
<a name="l00066"></a>00066             <span class="keywordflow">case</span> 4 : output += <span class="keyword">static_cast&lt;</span>Uint8<span class="keyword">&gt;</span>(*begin++); output &lt;&lt;= 6;
<a name="l00067"></a>00067             <span class="keywordflow">case</span> 3 : output += <span class="keyword">static_cast&lt;</span>Uint8<span class="keyword">&gt;</span>(*begin++); output &lt;&lt;= 6;
<a name="l00068"></a>00068             <span class="keywordflow">case</span> 2 : output += <span class="keyword">static_cast&lt;</span>Uint8<span class="keyword">&gt;</span>(*begin++); output &lt;&lt;= 6;
<a name="l00069"></a>00069             <span class="keywordflow">case</span> 1 : output += <span class="keyword">static_cast&lt;</span>Uint8<span class="keyword">&gt;</span>(*begin++); output &lt;&lt;= 6;
<a name="l00070"></a>00070             <span class="keywordflow">case</span> 0 : output += <span class="keyword">static_cast&lt;</span>Uint8<span class="keyword">&gt;</span>(*begin++);
<a name="l00071"></a>00071         }
<a name="l00072"></a>00072         output -= offsets[trailingBytes];
<a name="l00073"></a>00073     }
<a name="l00074"></a>00074     <span class="keywordflow">else</span>
<a name="l00075"></a>00075     {
<a name="l00076"></a>00076         <span class="comment">// Incomplete character</span>
<a name="l00077"></a>00077         begin = end;
<a name="l00078"></a>00078         output = replacement;
<a name="l00079"></a>00079     }
<a name="l00080"></a>00080 
<a name="l00081"></a>00081     <span class="keywordflow">return</span> begin;
<a name="l00082"></a>00082 }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 
<a name="l00086"></a>00086 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Out&gt;
<a name="l00087"></a>00087 Out Utf&lt;8&gt;::encode(Uint32 input, Out output, Uint8 replacement)
<a name="l00088"></a>00088 {
<a name="l00089"></a>00089     <span class="comment">// Some useful precomputed data</span>
<a name="l00090"></a>00090     <span class="keyword">static</span> <span class="keyword">const</span> Uint8 firstBytes[7] =
<a name="l00091"></a>00091     {
<a name="l00092"></a>00092         0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC
<a name="l00093"></a>00093     };
<a name="l00094"></a>00094 
<a name="l00095"></a>00095     <span class="comment">// encode the character</span>
<a name="l00096"></a>00096     <span class="keywordflow">if</span> ((input &gt; 0x0010FFFF) || ((input &gt;= 0xD800) &amp;&amp; (input &lt;= 0xDBFF)))
<a name="l00097"></a>00097     {
<a name="l00098"></a>00098         <span class="comment">// Invalid character</span>
<a name="l00099"></a>00099         <span class="keywordflow">if</span> (replacement)
<a name="l00100"></a>00100             *output++ = replacement;
<a name="l00101"></a>00101     }
<a name="l00102"></a>00102     <span class="keywordflow">else</span>
<a name="l00103"></a>00103     {
<a name="l00104"></a>00104         <span class="comment">// Valid character</span>
<a name="l00105"></a>00105 
<a name="l00106"></a>00106         <span class="comment">// Get the number of bytes to write</span>
<a name="l00107"></a>00107         <span class="keywordtype">int</span> bytestoWrite = 1;
<a name="l00108"></a>00108         <span class="keywordflow">if</span>      (input &lt;  0x80)       bytestoWrite = 1;
<a name="l00109"></a>00109         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input &lt;  0x800)      bytestoWrite = 2;
<a name="l00110"></a>00110         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input &lt;  0x10000)    bytestoWrite = 3;
<a name="l00111"></a>00111         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input &lt;= 0x0010FFFF) bytestoWrite = 4;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113         <span class="comment">// Extract the bytes to write</span>
<a name="l00114"></a>00114         Uint8 bytes[4];
<a name="l00115"></a>00115         <span class="keywordflow">switch</span> (bytestoWrite)
<a name="l00116"></a>00116         {
<a name="l00117"></a>00117             <span class="keywordflow">case</span> 4 : bytes[3] = <span class="keyword">static_cast&lt;</span>Uint8<span class="keyword">&gt;</span>((input | 0x80) &amp; 0xBF); input &gt;&gt;= 6;
<a name="l00118"></a>00118             <span class="keywordflow">case</span> 3 : bytes[2] = <span class="keyword">static_cast&lt;</span>Uint8<span class="keyword">&gt;</span>((input | 0x80) &amp; 0xBF); input &gt;&gt;= 6;
<a name="l00119"></a>00119             <span class="keywordflow">case</span> 2 : bytes[1] = <span class="keyword">static_cast&lt;</span>Uint8<span class="keyword">&gt;</span>((input | 0x80) &amp; 0xBF); input &gt;&gt;= 6;
<a name="l00120"></a>00120             <span class="keywordflow">case</span> 1 : bytes[0] = <span class="keyword">static_cast&lt;</span>Uint8<span class="keyword">&gt;</span> (input | firstBytes[bytestoWrite]);
<a name="l00121"></a>00121         }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123         <span class="comment">// Add them to the output</span>
<a name="l00124"></a>00124         <span class="keyword">const</span> Uint8* currentByte = bytes;
<a name="l00125"></a>00125         <span class="keywordflow">switch</span> (bytestoWrite)
<a name="l00126"></a>00126         {
<a name="l00127"></a>00127             <span class="keywordflow">case</span> 4 : *output++ = *currentByte++;
<a name="l00128"></a>00128             <span class="keywordflow">case</span> 3 : *output++ = *currentByte++;
<a name="l00129"></a>00129             <span class="keywordflow">case</span> 2 : *output++ = *currentByte++;
<a name="l00130"></a>00130             <span class="keywordflow">case</span> 1 : *output++ = *currentByte++;
<a name="l00131"></a>00131         }
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134     <span class="keywordflow">return</span> output;
<a name="l00135"></a>00135 }
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 
<a name="l00139"></a>00139 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In&gt;
<a name="l00140"></a>00140 In Utf&lt;8&gt;::next(In begin, In end)
<a name="l00141"></a>00141 {
<a name="l00142"></a>00142     Uint32 codepoint;
<a name="l00143"></a>00143     <span class="keywordflow">return</span> decode(begin, end, codepoint);
<a name="l00144"></a>00144 }
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 
<a name="l00148"></a>00148 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In&gt;
<a name="l00149"></a>00149 std::size_t Utf&lt;8&gt;::count(In begin, In end)
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151     std::size_t length = 0;
<a name="l00152"></a>00152     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00153"></a>00153     {
<a name="l00154"></a>00154         begin = next(begin, end);
<a name="l00155"></a>00155         ++length;
<a name="l00156"></a>00156     }
<a name="l00157"></a>00157 
<a name="l00158"></a>00158     <span class="keywordflow">return</span> length;
<a name="l00159"></a>00159 }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 
<a name="l00163"></a>00163 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00164"></a>00164 Out Utf&lt;8&gt;::fromAnsi(In begin, In end, Out output, <span class="keyword">const</span> std::locale&amp; locale)
<a name="l00165"></a>00165 {
<a name="l00166"></a>00166     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00167"></a>00167     {
<a name="l00168"></a>00168         Uint32 codepoint = Utf&lt;32&gt;::decodeAnsi(*begin++, locale);
<a name="l00169"></a>00169         output = encode(codepoint, output);
<a name="l00170"></a>00170     }
<a name="l00171"></a>00171 
<a name="l00172"></a>00172     <span class="keywordflow">return</span> output;
<a name="l00173"></a>00173 }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 
<a name="l00177"></a>00177 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00178"></a>00178 Out Utf&lt;8&gt;::fromWide(In begin, In end, Out output)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00181"></a>00181     {
<a name="l00182"></a>00182         Uint32 codepoint = Utf&lt;32&gt;::decodeWide(*begin++);
<a name="l00183"></a>00183         output = encode(codepoint, output);
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186     <span class="keywordflow">return</span> output;
<a name="l00187"></a>00187 }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 
<a name="l00191"></a>00191 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00192"></a>00192 Out Utf&lt;8&gt;::fromLatin1(In begin, In end, Out output)
<a name="l00193"></a>00193 {
<a name="l00194"></a>00194     <span class="comment">// Latin-1 is directly compatible with Unicode encodings,</span>
<a name="l00195"></a>00195     <span class="comment">// and can thus be treated as (a sub-range of) UTF-32</span>
<a name="l00196"></a>00196     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00197"></a>00197         output = encode(*begin++, output);
<a name="l00198"></a>00198 
<a name="l00199"></a>00199     <span class="keywordflow">return</span> output;
<a name="l00200"></a>00200 }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 
<a name="l00204"></a>00204 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00205"></a>00205 Out Utf&lt;8&gt;::toAnsi(In begin, In end, Out output, <span class="keywordtype">char</span> replacement, <span class="keyword">const</span> std::locale&amp; locale)
<a name="l00206"></a>00206 {
<a name="l00207"></a>00207     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00208"></a>00208     {
<a name="l00209"></a>00209         Uint32 codepoint;
<a name="l00210"></a>00210         begin = decode(begin, end, codepoint);
<a name="l00211"></a>00211         output = Utf&lt;32&gt;::encodeAnsi(codepoint, output, replacement, locale);
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213 
<a name="l00214"></a>00214     <span class="keywordflow">return</span> output;
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 
<a name="l00219"></a>00219 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00220"></a>00220 Out Utf&lt;8&gt;::toWide(In begin, In end, Out output, <span class="keywordtype">wchar_t</span> replacement)
<a name="l00221"></a>00221 {
<a name="l00222"></a>00222     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00223"></a>00223     {
<a name="l00224"></a>00224         Uint32 codepoint;
<a name="l00225"></a>00225         begin = decode(begin, end, codepoint);
<a name="l00226"></a>00226         output = Utf&lt;32&gt;::encodeWide(codepoint, output, replacement);
<a name="l00227"></a>00227     }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229     <span class="keywordflow">return</span> output;
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 
<a name="l00234"></a>00234 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00235"></a>00235 Out Utf&lt;8&gt;::toLatin1(In begin, In end, Out output, <span class="keywordtype">char</span> replacement)
<a name="l00236"></a>00236 {
<a name="l00237"></a>00237     <span class="comment">// Latin-1 is directly compatible with Unicode encodings,</span>
<a name="l00238"></a>00238     <span class="comment">// and can thus be treated as (a sub-range of) UTF-32</span>
<a name="l00239"></a>00239     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00240"></a>00240     {
<a name="l00241"></a>00241         Uint32 codepoint;
<a name="l00242"></a>00242         begin = decode(begin, end, codepoint);
<a name="l00243"></a>00243         *output++ = codepoint &lt; 256 ? static_cast&lt;char&gt;(codepoint) : replacement;
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     <span class="keywordflow">return</span> output;
<a name="l00247"></a>00247 }
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 
<a name="l00251"></a>00251 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00252"></a>00252 Out Utf&lt;8&gt;::toUtf8(In begin, In end, Out output)
<a name="l00253"></a>00253 {
<a name="l00254"></a>00254     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00255"></a>00255         *output++ = *begin++;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     <span class="keywordflow">return</span> output;
<a name="l00258"></a>00258 }
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 
<a name="l00262"></a>00262 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00263"></a>00263 Out Utf&lt;8&gt;::toUtf16(In begin, In end, Out output)
<a name="l00264"></a>00264 {
<a name="l00265"></a>00265     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00266"></a>00266     {
<a name="l00267"></a>00267         Uint32 codepoint;
<a name="l00268"></a>00268         begin = decode(begin, end, codepoint);
<a name="l00269"></a>00269         output = Utf&lt;16&gt;::encode(codepoint, output);
<a name="l00270"></a>00270     }
<a name="l00271"></a>00271 
<a name="l00272"></a>00272     <span class="keywordflow">return</span> output;
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 
<a name="l00277"></a>00277 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00278"></a>00278 Out Utf&lt;8&gt;::toUtf32(In begin, In end, Out output)
<a name="l00279"></a>00279 {
<a name="l00280"></a>00280     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00281"></a>00281     {
<a name="l00282"></a>00282         Uint32 codepoint;
<a name="l00283"></a>00283         begin = decode(begin, end, codepoint);
<a name="l00284"></a>00284         *output++ = codepoint;
<a name="l00285"></a>00285     }
<a name="l00286"></a>00286 
<a name="l00287"></a>00287     <span class="keywordflow">return</span> output;
<a name="l00288"></a>00288 }
<a name="l00289"></a>00289 
<a name="l00290"></a>00290 
<a name="l00292"></a>00292 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In&gt;
<a name="l00293"></a>00293 In Utf&lt;16&gt;::decode(In begin, In end, Uint32&amp; output, Uint32 replacement)
<a name="l00294"></a>00294 {
<a name="l00295"></a>00295     Uint16 first = *begin++;
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     <span class="comment">// If it&#39;s a surrogate pair, first convert to a single UTF-32 character</span>
<a name="l00298"></a>00298     <span class="keywordflow">if</span> ((first &gt;= 0xD800) &amp;&amp; (first &lt;= 0xDBFF))
<a name="l00299"></a>00299     {
<a name="l00300"></a>00300         <span class="keywordflow">if</span> (begin &lt; end)
<a name="l00301"></a>00301         {
<a name="l00302"></a>00302             Uint32 second = *begin++;
<a name="l00303"></a>00303             <span class="keywordflow">if</span> ((second &gt;= 0xDC00) &amp;&amp; (second &lt;= 0xDFFF))
<a name="l00304"></a>00304             {
<a name="l00305"></a>00305                 <span class="comment">// The second element is valid: convert the two elements to a UTF-32 character</span>
<a name="l00306"></a>00306                 output = <span class="keyword">static_cast&lt;</span>Uint32<span class="keyword">&gt;</span>(((first - 0xD800) &lt;&lt; 10) + (second - 0xDC00) + 0x0010000);
<a name="l00307"></a>00307             }
<a name="l00308"></a>00308             <span class="keywordflow">else</span>
<a name="l00309"></a>00309             {
<a name="l00310"></a>00310                 <span class="comment">// Invalid character</span>
<a name="l00311"></a>00311                 output = replacement;
<a name="l00312"></a>00312             }
<a name="l00313"></a>00313         }
<a name="l00314"></a>00314         <span class="keywordflow">else</span>
<a name="l00315"></a>00315         {
<a name="l00316"></a>00316             <span class="comment">// Invalid character</span>
<a name="l00317"></a>00317             begin = end;
<a name="l00318"></a>00318             output = replacement;
<a name="l00319"></a>00319         }
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321     <span class="keywordflow">else</span>
<a name="l00322"></a>00322     {
<a name="l00323"></a>00323         <span class="comment">// We can make a direct copy</span>
<a name="l00324"></a>00324         output = first;
<a name="l00325"></a>00325     }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327     <span class="keywordflow">return</span> begin;
<a name="l00328"></a>00328 }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 
<a name="l00332"></a>00332 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Out&gt;
<a name="l00333"></a>00333 Out Utf&lt;16&gt;::encode(Uint32 input, Out output, Uint16 replacement)
<a name="l00334"></a>00334 {
<a name="l00335"></a>00335     <span class="keywordflow">if</span> (input &lt; 0xFFFF)
<a name="l00336"></a>00336     {
<a name="l00337"></a>00337         <span class="comment">// The character can be copied directly, we just need to check if it&#39;s in the valid range</span>
<a name="l00338"></a>00338         <span class="keywordflow">if</span> ((input &gt;= 0xD800) &amp;&amp; (input &lt;= 0xDFFF))
<a name="l00339"></a>00339         {
<a name="l00340"></a>00340             <span class="comment">// Invalid character (this range is reserved)</span>
<a name="l00341"></a>00341             <span class="keywordflow">if</span> (replacement)
<a name="l00342"></a>00342                 *output++ = replacement;
<a name="l00343"></a>00343         }
<a name="l00344"></a>00344         <span class="keywordflow">else</span>
<a name="l00345"></a>00345         {
<a name="l00346"></a>00346             <span class="comment">// Valid character directly convertible to a single UTF-16 character</span>
<a name="l00347"></a>00347             *output++ = <span class="keyword">static_cast&lt;</span>Uint16<span class="keyword">&gt;</span>(input);
<a name="l00348"></a>00348         }
<a name="l00349"></a>00349     }
<a name="l00350"></a>00350     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (input &gt; 0x0010FFFF)
<a name="l00351"></a>00351     {
<a name="l00352"></a>00352         <span class="comment">// Invalid character (greater than the maximum unicode value)</span>
<a name="l00353"></a>00353         <span class="keywordflow">if</span> (replacement)
<a name="l00354"></a>00354             *output++ = replacement;
<a name="l00355"></a>00355     }
<a name="l00356"></a>00356     <span class="keywordflow">else</span>
<a name="l00357"></a>00357     {
<a name="l00358"></a>00358         <span class="comment">// The input character will be converted to two UTF-16 elements</span>
<a name="l00359"></a>00359         input -= 0x0010000;
<a name="l00360"></a>00360         *output++ = <span class="keyword">static_cast&lt;</span>Uint16<span class="keyword">&gt;</span>((input &gt;&gt; 10)     + 0xD800);
<a name="l00361"></a>00361         *output++ = <span class="keyword">static_cast&lt;</span>Uint16<span class="keyword">&gt;</span>((input &amp; 0x3FFUL) + 0xDC00);
<a name="l00362"></a>00362     }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364     <span class="keywordflow">return</span> output;
<a name="l00365"></a>00365 }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 
<a name="l00369"></a>00369 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In&gt;
<a name="l00370"></a>00370 In Utf&lt;16&gt;::next(In begin, In end)
<a name="l00371"></a>00371 {
<a name="l00372"></a>00372     Uint32 codepoint;
<a name="l00373"></a>00373     <span class="keywordflow">return</span> decode(begin, end, codepoint);
<a name="l00374"></a>00374 }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 
<a name="l00378"></a>00378 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In&gt;
<a name="l00379"></a>00379 std::size_t Utf&lt;16&gt;::count(In begin, In end)
<a name="l00380"></a>00380 {
<a name="l00381"></a>00381     std::size_t length = 0;
<a name="l00382"></a>00382     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00383"></a>00383     {
<a name="l00384"></a>00384         begin = next(begin, end);
<a name="l00385"></a>00385         ++length;
<a name="l00386"></a>00386     }
<a name="l00387"></a>00387 
<a name="l00388"></a>00388     <span class="keywordflow">return</span> length;
<a name="l00389"></a>00389 }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 
<a name="l00393"></a>00393 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00394"></a>00394 Out Utf&lt;16&gt;::fromAnsi(In begin, In end, Out output, <span class="keyword">const</span> std::locale&amp; locale)
<a name="l00395"></a>00395 {
<a name="l00396"></a>00396     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00397"></a>00397     {
<a name="l00398"></a>00398         Uint32 codepoint = Utf&lt;32&gt;::decodeAnsi(*begin++, locale);
<a name="l00399"></a>00399         output = encode(codepoint, output);
<a name="l00400"></a>00400     }
<a name="l00401"></a>00401 
<a name="l00402"></a>00402     <span class="keywordflow">return</span> output;
<a name="l00403"></a>00403 }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 
<a name="l00407"></a>00407 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00408"></a>00408 Out Utf&lt;16&gt;::fromWide(In begin, In end, Out output)
<a name="l00409"></a>00409 {
<a name="l00410"></a>00410     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00411"></a>00411     {
<a name="l00412"></a>00412         Uint32 codepoint = Utf&lt;32&gt;::decodeWide(*begin++);
<a name="l00413"></a>00413         output = encode(codepoint, output);
<a name="l00414"></a>00414     }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416     <span class="keywordflow">return</span> output;
<a name="l00417"></a>00417 }
<a name="l00418"></a>00418 
<a name="l00419"></a>00419 
<a name="l00421"></a>00421 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00422"></a>00422 Out Utf&lt;16&gt;::fromLatin1(In begin, In end, Out output)
<a name="l00423"></a>00423 {
<a name="l00424"></a>00424     <span class="comment">// Latin-1 is directly compatible with Unicode encodings,</span>
<a name="l00425"></a>00425     <span class="comment">// and can thus be treated as (a sub-range of) UTF-32</span>
<a name="l00426"></a>00426     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00427"></a>00427         *output++ = *begin++;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429     <span class="keywordflow">return</span> output;
<a name="l00430"></a>00430 }
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 
<a name="l00434"></a>00434 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00435"></a>00435 Out Utf&lt;16&gt;::toAnsi(In begin, In end, Out output, <span class="keywordtype">char</span> replacement, <span class="keyword">const</span> std::locale&amp; locale)
<a name="l00436"></a>00436 {
<a name="l00437"></a>00437     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00438"></a>00438     {
<a name="l00439"></a>00439         Uint32 codepoint;
<a name="l00440"></a>00440         begin = decode(begin, end, codepoint);
<a name="l00441"></a>00441         output = Utf&lt;32&gt;::encodeAnsi(codepoint, output, replacement, locale);
<a name="l00442"></a>00442     }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444     <span class="keywordflow">return</span> output;
<a name="l00445"></a>00445 }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 
<a name="l00449"></a>00449 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00450"></a>00450 Out Utf&lt;16&gt;::toWide(In begin, In end, Out output, <span class="keywordtype">wchar_t</span> replacement)
<a name="l00451"></a>00451 {
<a name="l00452"></a>00452     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00453"></a>00453     {
<a name="l00454"></a>00454         Uint32 codepoint;
<a name="l00455"></a>00455         begin = decode(begin, end, codepoint);
<a name="l00456"></a>00456         output = Utf&lt;32&gt;::encodeWide(codepoint, output, replacement);
<a name="l00457"></a>00457     }
<a name="l00458"></a>00458 
<a name="l00459"></a>00459     <span class="keywordflow">return</span> output;
<a name="l00460"></a>00460 }
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 
<a name="l00464"></a>00464 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00465"></a>00465 Out Utf&lt;16&gt;::toLatin1(In begin, In end, Out output, <span class="keywordtype">char</span> replacement)
<a name="l00466"></a>00466 {
<a name="l00467"></a>00467     <span class="comment">// Latin-1 is directly compatible with Unicode encodings,</span>
<a name="l00468"></a>00468     <span class="comment">// and can thus be treated as (a sub-range of) UTF-32</span>
<a name="l00469"></a>00469     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00470"></a>00470     {
<a name="l00471"></a>00471         *output++ = *begin &lt; 256 ? static_cast&lt;char&gt;(*begin) : replacement;
<a name="l00472"></a>00472         begin++;
<a name="l00473"></a>00473     }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475     <span class="keywordflow">return</span> output;
<a name="l00476"></a>00476 }
<a name="l00477"></a>00477 
<a name="l00478"></a>00478 
<a name="l00480"></a>00480 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00481"></a>00481 Out Utf&lt;16&gt;::toUtf8(In begin, In end, Out output)
<a name="l00482"></a>00482 {
<a name="l00483"></a>00483     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00484"></a>00484     {
<a name="l00485"></a>00485         Uint32 codepoint;
<a name="l00486"></a>00486         begin = decode(begin, end, codepoint);
<a name="l00487"></a>00487         output = Utf&lt;8&gt;::encode(codepoint, output);
<a name="l00488"></a>00488     }
<a name="l00489"></a>00489 
<a name="l00490"></a>00490     <span class="keywordflow">return</span> output;
<a name="l00491"></a>00491 }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 
<a name="l00495"></a>00495 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00496"></a>00496 Out Utf&lt;16&gt;::toUtf16(In begin, In end, Out output)
<a name="l00497"></a>00497 {
<a name="l00498"></a>00498     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00499"></a>00499         *output++ = *begin++;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501     <span class="keywordflow">return</span> output;
<a name="l00502"></a>00502 }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 
<a name="l00506"></a>00506 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00507"></a>00507 Out Utf&lt;16&gt;::toUtf32(In begin, In end, Out output)
<a name="l00508"></a>00508 {
<a name="l00509"></a>00509     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00510"></a>00510     {
<a name="l00511"></a>00511         Uint32 codepoint;
<a name="l00512"></a>00512         begin = decode(begin, end, codepoint);
<a name="l00513"></a>00513         *output++ = codepoint;
<a name="l00514"></a>00514     }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516     <span class="keywordflow">return</span> output;
<a name="l00517"></a>00517 }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 
<a name="l00521"></a>00521 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In&gt;
<a name="l00522"></a>00522 In Utf&lt;32&gt;::decode(In begin, In <span class="comment">/*end*/</span>, Uint32&amp; output, Uint32 <span class="comment">/*replacement*/</span>)
<a name="l00523"></a>00523 {
<a name="l00524"></a>00524     output = *begin++;
<a name="l00525"></a>00525     <span class="keywordflow">return</span> begin;
<a name="l00526"></a>00526 }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 
<a name="l00530"></a>00530 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Out&gt;
<a name="l00531"></a>00531 Out Utf&lt;32&gt;::encode(Uint32 input, Out output, Uint32 <span class="comment">/*replacement*/</span>)
<a name="l00532"></a>00532 {
<a name="l00533"></a>00533     *output++ = input;
<a name="l00534"></a>00534     <span class="keywordflow">return</span> output;
<a name="l00535"></a>00535 }
<a name="l00536"></a>00536 
<a name="l00537"></a>00537 
<a name="l00539"></a>00539 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In&gt;
<a name="l00540"></a>00540 In Utf&lt;32&gt;::next(In begin, In <span class="comment">/*end*/</span>)
<a name="l00541"></a>00541 {
<a name="l00542"></a>00542     <span class="keywordflow">return</span> ++begin;
<a name="l00543"></a>00543 }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 
<a name="l00547"></a>00547 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In&gt;
<a name="l00548"></a>00548 std::size_t Utf&lt;32&gt;::count(In begin, In end)
<a name="l00549"></a>00549 {
<a name="l00550"></a>00550     <span class="keywordflow">return</span> begin - end;
<a name="l00551"></a>00551 }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 
<a name="l00555"></a>00555 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00556"></a>00556 Out Utf&lt;32&gt;::fromAnsi(In begin, In end, Out output, <span class="keyword">const</span> std::locale&amp; locale)
<a name="l00557"></a>00557 {
<a name="l00558"></a>00558     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00559"></a>00559         *output++ = decodeAnsi(*begin++, locale);
<a name="l00560"></a>00560 
<a name="l00561"></a>00561     <span class="keywordflow">return</span> output;
<a name="l00562"></a>00562 }
<a name="l00563"></a>00563 
<a name="l00564"></a>00564 
<a name="l00566"></a>00566 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00567"></a>00567 Out Utf&lt;32&gt;::fromWide(In begin, In end, Out output)
<a name="l00568"></a>00568 {
<a name="l00569"></a>00569     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00570"></a>00570         *output++ = decodeWide(*begin++);
<a name="l00571"></a>00571 
<a name="l00572"></a>00572     <span class="keywordflow">return</span> output;
<a name="l00573"></a>00573 }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 
<a name="l00577"></a>00577 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00578"></a>00578 Out Utf&lt;32&gt;::fromLatin1(In begin, In end, Out output)
<a name="l00579"></a>00579 {
<a name="l00580"></a>00580     <span class="comment">// Latin-1 is directly compatible with Unicode encodings,</span>
<a name="l00581"></a>00581     <span class="comment">// and can thus be treated as (a sub-range of) UTF-32</span>
<a name="l00582"></a>00582     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00583"></a>00583         *output++ = *begin++;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585     <span class="keywordflow">return</span> output;
<a name="l00586"></a>00586 }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588 
<a name="l00590"></a>00590 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00591"></a>00591 Out Utf&lt;32&gt;::toAnsi(In begin, In end, Out output, <span class="keywordtype">char</span> replacement, <span class="keyword">const</span> std::locale&amp; locale)
<a name="l00592"></a>00592 {
<a name="l00593"></a>00593     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00594"></a>00594         output = encodeAnsi(*begin++, output, replacement, locale);
<a name="l00595"></a>00595 
<a name="l00596"></a>00596     <span class="keywordflow">return</span> output;
<a name="l00597"></a>00597 }
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 
<a name="l00601"></a>00601 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00602"></a>00602 Out Utf&lt;32&gt;::toWide(In begin, In end, Out output, <span class="keywordtype">wchar_t</span> replacement)
<a name="l00603"></a>00603 {
<a name="l00604"></a>00604     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00605"></a>00605         output = encodeWide(*begin++, output, replacement);
<a name="l00606"></a>00606 
<a name="l00607"></a>00607     <span class="keywordflow">return</span> output;
<a name="l00608"></a>00608 }
<a name="l00609"></a>00609 
<a name="l00610"></a>00610 
<a name="l00612"></a>00612 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00613"></a>00613 Out Utf&lt;32&gt;::toLatin1(In begin, In end, Out output, <span class="keywordtype">char</span> replacement)
<a name="l00614"></a>00614 {
<a name="l00615"></a>00615     <span class="comment">// Latin-1 is directly compatible with Unicode encodings,</span>
<a name="l00616"></a>00616     <span class="comment">// and can thus be treated as (a sub-range of) UTF-32</span>
<a name="l00617"></a>00617     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00618"></a>00618     {
<a name="l00619"></a>00619         *output++ = *begin &lt; 256 ? static_cast&lt;char&gt;(*begin) : replacement;
<a name="l00620"></a>00620         begin++;
<a name="l00621"></a>00621     }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623     <span class="keywordflow">return</span> output;
<a name="l00624"></a>00624 }
<a name="l00625"></a>00625 
<a name="l00626"></a>00626 
<a name="l00628"></a>00628 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00629"></a>00629 Out Utf&lt;32&gt;::toUtf8(In begin, In end, Out output)
<a name="l00630"></a>00630 {
<a name="l00631"></a>00631     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00632"></a>00632         output = Utf&lt;8&gt;::encode(*begin++, output);
<a name="l00633"></a>00633 
<a name="l00634"></a>00634     <span class="keywordflow">return</span> output;
<a name="l00635"></a>00635 }
<a name="l00636"></a>00636 
<a name="l00638"></a>00638 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00639"></a>00639 Out Utf&lt;32&gt;::toUtf16(In begin, In end, Out output)
<a name="l00640"></a>00640 {
<a name="l00641"></a>00641     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00642"></a>00642         output = Utf&lt;16&gt;::encode(*begin++, output);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644     <span class="keywordflow">return</span> output;
<a name="l00645"></a>00645 }
<a name="l00646"></a>00646 
<a name="l00647"></a>00647 
<a name="l00649"></a>00649 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In, <span class="keyword">typename</span> Out&gt;
<a name="l00650"></a>00650 Out Utf&lt;32&gt;::toUtf32(In begin, In end, Out output)
<a name="l00651"></a>00651 {
<a name="l00652"></a>00652     <span class="keywordflow">while</span> (begin &lt; end)
<a name="l00653"></a>00653         *output++ = *begin++;
<a name="l00654"></a>00654 
<a name="l00655"></a>00655     <span class="keywordflow">return</span> output;
<a name="l00656"></a>00656 }
<a name="l00657"></a>00657 
<a name="l00658"></a>00658 
<a name="l00660"></a>00660 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In&gt;
<a name="l00661"></a>00661 Uint32 Utf&lt;32&gt;::decodeAnsi(In input, <span class="keyword">const</span> std::locale&amp; locale)
<a name="l00662"></a>00662 {
<a name="l00663"></a>00663     <span class="comment">// On Windows, gcc&#39;s standard library (glibc++) has almost</span>
<a name="l00664"></a>00664     <span class="comment">// no support for Unicode stuff. As a consequence, in this</span>
<a name="l00665"></a>00665     <span class="comment">// context we can only use the default locale and ignore</span>
<a name="l00666"></a>00666     <span class="comment">// the one passed as parameter.</span>
<a name="l00667"></a>00667 
<a name="l00668"></a>00668 <span class="preprocessor">    #if defined(SFML_SYSTEM_WINDOWS) &amp;&amp;                       </span><span class="comment">/* if Windows ... */</span>                          \
<a name="l00669"></a>00669        (defined(__GLIBCPP__) || defined (__GLIBCXX__)) &amp;&amp;     <span class="comment">/* ... and standard library is glibc++ ... */</span> \
<a name="l00670"></a>00670       !(defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)) <span class="comment">/* ... and STLPort is not used on top of it */</span>
<a name="l00671"></a>00671 
<a name="l00672"></a>00672         (void)locale; <span class="comment">// to avoid warnings</span>
<a name="l00673"></a>00673 
<a name="l00674"></a>00674         <span class="keywordtype">wchar_t</span> character = 0;
<a name="l00675"></a>00675         mbtowc(&amp;character, &amp;input, 1);
<a name="l00676"></a>00676         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Uint32<span class="keyword">&gt;</span>(character);
<a name="l00677"></a>00677 
<a name="l00678"></a>00678 <span class="preprocessor">    #else</span>
<a name="l00679"></a>00679 <span class="preprocessor"></span>
<a name="l00680"></a>00680         <span class="comment">// Get the facet of the locale which deals with character conversion</span>
<a name="l00681"></a>00681         <span class="keyword">const</span> std::ctype&lt;wchar_t&gt;&amp; facet = std::use_facet&lt; std::ctype&lt;wchar_t&gt; &gt;(locale);
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         <span class="comment">// Use the facet to convert each character of the input string</span>
<a name="l00684"></a>00684         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>Uint32<span class="keyword">&gt;</span>(facet.widen(input));
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 <span class="preprocessor">    #endif</span>
<a name="l00687"></a>00687 <span class="preprocessor"></span>}
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 
<a name="l00691"></a>00691 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> In&gt;
<a name="l00692"></a>00692 Uint32 Utf&lt;32&gt;::decodeWide(In input)
<a name="l00693"></a>00693 {
<a name="l00694"></a>00694     <span class="comment">// The encoding of wide characters is not well defined and is left to the system;</span>
<a name="l00695"></a>00695     <span class="comment">// however we can safely assume that it is UCS-2 on Windows and</span>
<a name="l00696"></a>00696     <span class="comment">// UCS-4 on Unix systems.</span>
<a name="l00697"></a>00697     <span class="comment">// In both cases, a simple copy is enough (UCS-2 is a subset of UCS-4,</span>
<a name="l00698"></a>00698     <span class="comment">// and UCS-4 *is* UTF-32).</span>
<a name="l00699"></a>00699 
<a name="l00700"></a>00700     <span class="keywordflow">return</span> input;
<a name="l00701"></a>00701 }
<a name="l00702"></a>00702 
<a name="l00703"></a>00703 
<a name="l00705"></a>00705 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Out&gt;
<a name="l00706"></a>00706 Out Utf&lt;32&gt;::encodeAnsi(Uint32 codepoint, Out output, <span class="keywordtype">char</span> replacement, <span class="keyword">const</span> std::locale&amp; locale)
<a name="l00707"></a>00707 {
<a name="l00708"></a>00708     <span class="comment">// On Windows, gcc&#39;s standard library (glibc++) has almost</span>
<a name="l00709"></a>00709     <span class="comment">// no support for Unicode stuff. As a consequence, in this</span>
<a name="l00710"></a>00710     <span class="comment">// context we can only use the default locale and ignore</span>
<a name="l00711"></a>00711     <span class="comment">// the one passed as parameter.</span>
<a name="l00712"></a>00712 
<a name="l00713"></a>00713 <span class="preprocessor">    #if defined(SFML_SYSTEM_WINDOWS) &amp;&amp;                       </span><span class="comment">/* if Windows ... */</span>                          \
<a name="l00714"></a>00714        (defined(__GLIBCPP__) || defined (__GLIBCXX__)) &amp;&amp;     <span class="comment">/* ... and standard library is glibc++ ... */</span> \
<a name="l00715"></a>00715       !(defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)) <span class="comment">/* ... and STLPort is not used on top of it */</span>
<a name="l00716"></a>00716 
<a name="l00717"></a>00717         (void)locale; <span class="comment">// to avoid warnings</span>
<a name="l00718"></a>00718 
<a name="l00719"></a>00719         <span class="keywordtype">char</span> character = 0;
<a name="l00720"></a>00720         <span class="keywordflow">if</span> (wctomb(&amp;character, static_cast&lt;wchar_t&gt;(codepoint)) &gt;= 0)
<a name="l00721"></a>00721             *output++ = character;
<a name="l00722"></a>00722         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (replacement)
<a name="l00723"></a>00723             *output++ = replacement;
<a name="l00724"></a>00724 
<a name="l00725"></a>00725         <span class="keywordflow">return</span> output;
<a name="l00726"></a>00726 
<a name="l00727"></a>00727 <span class="preprocessor">    #else</span>
<a name="l00728"></a>00728 <span class="preprocessor"></span>
<a name="l00729"></a>00729         <span class="comment">// Get the facet of the locale which deals with character conversion</span>
<a name="l00730"></a>00730         <span class="keyword">const</span> std::ctype&lt;wchar_t&gt;&amp; facet = std::use_facet&lt; std::ctype&lt;wchar_t&gt; &gt;(locale);
<a name="l00731"></a>00731 
<a name="l00732"></a>00732         <span class="comment">// Use the facet to convert each character of the input string</span>
<a name="l00733"></a>00733         *output++ = facet.narrow(static_cast&lt;wchar_t&gt;(codepoint), replacement);
<a name="l00734"></a>00734 
<a name="l00735"></a>00735         <span class="keywordflow">return</span> output;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737 <span class="preprocessor">    #endif</span>
<a name="l00738"></a>00738 <span class="preprocessor"></span>}
<a name="l00739"></a>00739 
<a name="l00740"></a>00740 
<a name="l00742"></a>00742 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Out&gt;
<a name="l00743"></a>00743 Out Utf&lt;32&gt;::encodeWide(Uint32 codepoint, Out output, <span class="keywordtype">wchar_t</span> replacement)
<a name="l00744"></a>00744 {
<a name="l00745"></a>00745     <span class="comment">// The encoding of wide characters is not well defined and is left to the system;</span>
<a name="l00746"></a>00746     <span class="comment">// however we can safely assume that it is UCS-2 on Windows and</span>
<a name="l00747"></a>00747     <span class="comment">// UCS-4 on Unix systems.</span>
<a name="l00748"></a>00748     <span class="comment">// For UCS-2 we need to check if the source characters fits in (UCS-2 is a subset of UCS-4).</span>
<a name="l00749"></a>00749     <span class="comment">// For UCS-4 we can do a direct copy (UCS-4 *is* UTF-32).</span>
<a name="l00750"></a>00750 
<a name="l00751"></a>00751     <span class="keywordflow">switch</span> (<span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>))
<a name="l00752"></a>00752     {
<a name="l00753"></a>00753         <span class="keywordflow">case</span> 4:
<a name="l00754"></a>00754         {
<a name="l00755"></a>00755             *output++ = <span class="keyword">static_cast&lt;</span><span class="keywordtype">wchar_t</span><span class="keyword">&gt;</span>(codepoint);
<a name="l00756"></a>00756             <span class="keywordflow">break</span>;
<a name="l00757"></a>00757         }
<a name="l00758"></a>00758 
<a name="l00759"></a>00759         <span class="keywordflow">default</span>:
<a name="l00760"></a>00760         {
<a name="l00761"></a>00761             <span class="keywordflow">if</span> ((codepoint &lt;= 0xFFFF) &amp;&amp; ((codepoint &lt; 0xD800) || (codepoint &gt; 0xDFFF)))
<a name="l00762"></a>00762             {
<a name="l00763"></a>00763                 *output++ = <span class="keyword">static_cast&lt;</span><span class="keywordtype">wchar_t</span><span class="keyword">&gt;</span>(codepoint);
<a name="l00764"></a>00764             }
<a name="l00765"></a>00765             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (replacement)
<a name="l00766"></a>00766             {
<a name="l00767"></a>00767                 *output++ = replacement;
<a name="l00768"></a>00768             }
<a name="l00769"></a>00769             <span class="keywordflow">break</span>;
<a name="l00770"></a>00770         }
<a name="l00771"></a>00771     }
<a name="l00772"></a>00772 
<a name="l00773"></a>00773     <span class="keywordflow">return</span> output;
<a name="l00774"></a>00774 }
</pre></div></div><!-- contents -->

        <p id="footer">
            &nbsp;::&nbsp; Copyright &copy; 2007-2008 Laurent Gomila, all rights reserved &nbsp;::&nbsp;
            Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen 1.5.2</a> &nbsp;::&nbsp;
        </p>

    </body>
</html>
