<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>SFML - Simple and Fast Multimedia Library</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="tabs.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div id="logo">
            <img src="./logo.jpg" width="770" height="200" title="SFML home" alt="SFML logo" />
        </div>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.htm"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.htm"><span>Classes</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.htm"><span>Class&#160;List</span></a></li>
      <li><a href="classes.htm"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.htm"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.htm"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>sf</b>      </li>
      <li class="navelem"><a class="el" href="classsf_1_1RenderWindow.htm">RenderWindow</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">sf::RenderWindow Class Reference<div class="ingroups"><a class="el" href="group__graphics.htm">Graphics module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="sf::RenderWindow" --><!-- doxytag: inherits="sf::Window,sf::RenderTarget" -->
<p><a class="el" href="classsf_1_1Window.htm" title="Window that serves as a target for OpenGL rendering.">Window</a> that can serve as a target for 2D drawing.  
 <a href="classsf_1_1RenderWindow.htm#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RenderWindow_8hpp_source.htm">RenderWindow.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sf::RenderWindow:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsf_1_1RenderWindow.png" usemap="#sf::RenderWindow_map" alt=""/>
  <map id="sf::RenderWindow_map" name="sf::RenderWindow_map">
<area href="classsf_1_1Window.htm" title="Window that serves as a target for OpenGL rendering." alt="sf::Window" shape="rect" coords="61,56,174,80"/>
<area href="classsf_1_1RenderTarget.htm" title="Base class for all render targets (window, texture, ...)" alt="sf::RenderTarget" shape="rect" coords="246,56,359,80"/>
<area href="classsf_1_1GlResource.htm" title="Base class for classes that require an OpenGL context." alt="sf::GlResource" shape="rect" coords="0,0,113,24"/>
<area href="classsf_1_1NonCopyable.htm" title="Utility class that makes any derived class non-copyable." alt="sf::NonCopyable" shape="rect" coords="123,0,236,24"/>
<area href="classsf_1_1NonCopyable.htm" title="Utility class that makes any derived class non-copyable." alt="sf::NonCopyable" shape="rect" coords="246,0,359,24"/>
</map>
 </div></div>

<p><a href="classsf_1_1RenderWindow-members.htm">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderWindow.htm#a839bbf336bdcafb084dafc3076fc9021">RenderWindow</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a839bbf336bdcafb084dafc3076fc9021"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderWindow.htm#a828cf38403a246c11ae98a316f271941">RenderWindow</a> (<a class="el" href="classsf_1_1VideoMode.htm">VideoMode</a> mode, const std::string &amp;title, Uint32 style=Style::Default, const <a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a> &amp;settings=<a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new window.  <a href="#a828cf38403a246c11ae98a316f271941"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderWindow.htm#a25c0af7d515e710b6eebc9c6be952aa5">RenderWindow</a> (WindowHandle handle, const <a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a> &amp;settings=<a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the window from an existing control.  <a href="#a25c0af7d515e710b6eebc9c6be952aa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderWindow.htm#a3407e36bfc1752d723140438a825365c">~RenderWindow</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a3407e36bfc1752d723140438a825365c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsf_1_1Vector2.htm">Vector2u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderWindow.htm#a2c7ff414be32621a453745cf2a0f8a3e">getSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the rendering region of the window.  <a href="#a2c7ff414be32621a453745cf2a0f8a3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Image.htm">Image</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderWindow.htm#a9bd8655d0bac83145bfc329ea7a6d538">capture</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the current contents of the window to an image.  <a href="#a9bd8655d0bac83145bfc329ea7a6d538"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a21c51afab5ae676c9c8b325d453958d5">create</a> (<a class="el" href="classsf_1_1VideoMode.htm">VideoMode</a> mode, const std::string &amp;title, Uint32 style=Style::Default, const <a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a> &amp;settings=<a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (or recreate) the window.  <a href="#a21c51afab5ae676c9c8b325d453958d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#acf67483dc21f08d65c8835b3889b41b2">create</a> (WindowHandle handle, const <a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a> &amp;settings=<a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (or recreate) the window from an existing control.  <a href="#acf67483dc21f08d65c8835b3889b41b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a99d1e030387b0c26f5995670504fe7b5">close</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the window and destroy all the attached resources.  <a href="#a99d1e030387b0c26f5995670504fe7b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a5aa9c2b2b0e51d3423c2b66c80253337">isOpen</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether or not the window is open.  <a href="#a5aa9c2b2b0e51d3423c2b66c80253337"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a5a9d5c15facf25ad4d9b2b30caa0a2db">getSettings</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the settings of the OpenGL context of the window.  <a href="#a5a9d5c15facf25ad4d9b2b30caa0a2db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a338e996585faf82e93069858e3b531b7">pollEvent</a> (<a class="el" href="classsf_1_1Event.htm">Event</a> &amp;event)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the event on top of events stack, if any, and return it.  <a href="#a338e996585faf82e93069858e3b531b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#aaf02ab64fbc1d374eef3696df54137bc">waitEvent</a> (<a class="el" href="classsf_1_1Event.htm">Event</a> &amp;event)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for an event and return it.  <a href="#aaf02ab64fbc1d374eef3696df54137bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a2e6bc12612ea289afea8268fe37c8678">getPosition</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of the window.  <a href="#a2e6bc12612ea289afea8268fe37c8678"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a6c4078bfbf61c29bfc4b4732ce764f17">setPosition</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2i</a> &amp;position)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the position of the window on screen.  <a href="#a6c4078bfbf61c29bfc4b4732ce764f17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#ad6513418bb2963347cd1819a1810524d">setSize</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2u</a> size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of the rendering region of the window.  <a href="#ad6513418bb2963347cd1819a1810524d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a7f419f99a799424376aba838abfbd273">setTitle</a> (const std::string &amp;title)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the title of the window.  <a href="#a7f419f99a799424376aba838abfbd273"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a63af61e026fba08e3153fd013620bcc0">setIcon</a> (unsigned int width, unsigned int height, const Uint8 *pixels)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the window's icon.  <a href="#a63af61e026fba08e3153fd013620bcc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a160f7f11a207603d7e99ce606e749703">setVisible</a> (bool visible)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Show or hide the window.  <a href="#a160f7f11a207603d7e99ce606e749703"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a59041c4556e0351048f8aff366034f61">setVerticalSyncEnabled</a> (bool enabled)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable vertical synchronization.  <a href="#a59041c4556e0351048f8aff366034f61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#aad3991c25e0a83afbb4d62febf9b7b14">setMouseCursorVisible</a> (bool visible)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Show or hide the mouse cursor.  <a href="#aad3991c25e0a83afbb4d62febf9b7b14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#aef9f2b14c10ecba8a8df95dd51c5bb73">setKeyRepeatEnabled</a> (bool enabled)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable automatic key-repeat.  <a href="#aef9f2b14c10ecba8a8df95dd51c5bb73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#af4322d315baf93405bf0d5087ad5e784">setFramerateLimit</a> (unsigned int limit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Limit the framerate to a maximum fixed frequency.  <a href="#af4322d315baf93405bf0d5087ad5e784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#aa45b8f54e29a6f59f1fc7ee66b2fab68">setJoystickThreshold</a> (float threshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the joystick threshold.  <a href="#aa45b8f54e29a6f59f1fc7ee66b2fab68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a17ccf8ece0ce0bf2f1e6698bcfa29731">setActive</a> (bool active=true) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate or deactivate the window as the current target for OpenGL rendering.  <a href="#a17ccf8ece0ce0bf2f1e6698bcfa29731"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#adabf839cb103ac96cfc82f781638772a">display</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Display on screen what has been rendered to the window so far.  <a href="#adabf839cb103ac96cfc82f781638772a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">WindowHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.htm#a26368e7162229f8637c34d80ab0f138e">getSystemHandle</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the OS-specific handle of the window.  <a href="#a26368e7162229f8637c34d80ab0f138e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a6bb6f0ba348f2b1e2f46114aeaf60f26">clear</a> (const <a class="el" href="classsf_1_1Color.htm">Color</a> &amp;color=<a class="el" href="classsf_1_1Color.htm">Color</a>(0, 0, 0, 255))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the entire target with a single color.  <a href="#a6bb6f0ba348f2b1e2f46114aeaf60f26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a063db6dd0a14913504af30e50cb6d946">setView</a> (const <a class="el" href="classsf_1_1View.htm">View</a> &amp;view)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the current active view.  <a href="#a063db6dd0a14913504af30e50cb6d946"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1View.htm">View</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a98f721cc6dc11478922427fedfb2288b">getView</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the view currently in use in the render target.  <a href="#a98f721cc6dc11478922427fedfb2288b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1View.htm">View</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a718b1aa6296bf855171699cc18251ced">getDefaultView</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default view of the render target.  <a href="#a718b1aa6296bf855171699cc18251ced"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Rect.htm">IntRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#aae035b0d45f87a0da2a28a0de6ba1086">getViewport</a> (const <a class="el" href="classsf_1_1View.htm">View</a> &amp;view) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the viewport of a view, applied to this render target.  <a href="#aae035b0d45f87a0da2a28a0de6ba1086"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#afc047333937f7cb7fe557aec60239233">convertCoords</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2i</a> &amp;point) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from target coordinates to view coordinates.  <a href="#afc047333937f7cb7fe557aec60239233"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Vector2.htm">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#ae5e7ba65ef73df2778b29b7fdcdb20ee">convertCoords</a> (const <a class="el" href="classsf_1_1Vector2.htm">Vector2i</a> &amp;point, const <a class="el" href="classsf_1_1View.htm">View</a> &amp;view) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from target coordinates to view coordinates.  <a href="#ae5e7ba65ef73df2778b29b7fdcdb20ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a12417a3bcc245c41d957b29583556f39">draw</a> (const <a class="el" href="classsf_1_1Drawable.htm">Drawable</a> &amp;drawable, const <a class="el" href="classsf_1_1RenderStates.htm">RenderStates</a> &amp;states=<a class="el" href="classsf_1_1RenderStates.htm#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a drawable object to the render-target.  <a href="#a12417a3bcc245c41d957b29583556f39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#ab636d7363f6681077361ee274ba89a8d">draw</a> (const <a class="el" href="classsf_1_1Vertex.htm">Vertex</a> *vertices, unsigned int vertexCount, <a class="el" href="group__graphics.htm#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a> type, const <a class="el" href="classsf_1_1RenderStates.htm">RenderStates</a> &amp;states=<a class="el" href="classsf_1_1RenderStates.htm#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives defined by an array of vertices.  <a href="#ab636d7363f6681077361ee274ba89a8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a8d1998464ccc54e789aaf990242b47f7">pushGLStates</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the current OpenGL render states and matrices.  <a href="#a8d1998464ccc54e789aaf990242b47f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#ad5a98401113df931ddcd54c080f7aa8e">popGLStates</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the previously saved OpenGL render states and matrices.  <a href="#ad5a98401113df931ddcd54c080f7aa8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#aac7504990d27dada4bfe3c7866920765">resetGLStates</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal OpenGL states so that the target is ready for drawing.  <a href="#aac7504990d27dada4bfe3c7866920765"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderWindow.htm#a5bef0040b0fa87bed9fbd459c980d53a">onCreate</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called after the window has been created.  <a href="#a5bef0040b0fa87bed9fbd459c980d53a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderWindow.htm#a5c85fe482313562d33ffd24a194b6fef">onResize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called after the window has been resized.  <a href="#a5c85fe482313562d33ffd24a194b6fef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#af530274b34159d644e509b4b4dc43eb7">initialize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the common initialization step after creation.  <a href="#af530274b34159d644e509b4b4dc43eb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a3ed439c5445e9c7d7ff786ff37005efa">applyCurrentView</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the current view.  <a href="#a3ed439c5445e9c7d7ff786ff37005efa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#aefd4b1cc8e264598b94bd70aaac5bc99">applyBlendMode</a> (<a class="el" href="group__graphics.htm#ga80c52fe2f7050d7f7573b7ed3c995388">BlendMode</a> mode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a new blending mode.  <a href="#aefd4b1cc8e264598b94bd70aaac5bc99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a0b23bd7c287d0fc12b0521b649a0a0e0">applyTransform</a> (const <a class="el" href="classsf_1_1Transform.htm">Transform</a> &amp;transform)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a new transform.  <a href="#a0b23bd7c287d0fc12b0521b649a0a0e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#afb8a49305171aad158a27e0dfbb03709">applyTexture</a> (const <a class="el" href="classsf_1_1Texture.htm">Texture</a> *texture)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a new texture.  <a href="#afb8a49305171aad158a27e0dfbb03709"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.htm#a6f8bc92f07c70ccd57cbf632fe9de0ba">applyShader</a> (const <a class="el" href="classsf_1_1Shader.htm">Shader</a> *shader)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a new shader.  <a href="#a6f8bc92f07c70ccd57cbf632fe9de0ba"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classsf_1_1Window.htm" title="Window that serves as a target for OpenGL rendering.">Window</a> that can serve as a target for 2D drawing. </p>
<p><a class="el" href="classsf_1_1RenderWindow.htm" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a> is the main class of the Graphics module.</p>
<p>It defines an OS window that can be painted using the other classes of the graphics module.</p>
<p><a class="el" href="classsf_1_1RenderWindow.htm" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a> is derived from <a class="el" href="classsf_1_1Window.htm" title="Window that serves as a target for OpenGL rendering.">sf::Window</a>, thus it inherits all its features: events, window management, OpenGL rendering, etc. See the documentation of <a class="el" href="classsf_1_1Window.htm" title="Window that serves as a target for OpenGL rendering.">sf::Window</a> for a more complete description of all these features, as well as code examples.</p>
<p>On top of that, <a class="el" href="classsf_1_1RenderWindow.htm" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a> adds more features related to 2D drawing with the graphics module (see its base class <a class="el" href="classsf_1_1RenderTarget.htm" title="Base class for all render targets (window, texture, ...)">sf::RenderTarget</a> for more details). Here is a typical rendering and event loop with a <a class="el" href="classsf_1_1RenderWindow.htm" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a>:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Declare and create a new render-window</span>
 <a class="code" href="classsf_1_1RenderWindow.htm" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a> window(<a class="code" href="classsf_1_1VideoMode.htm" title="VideoMode defines a video mode (width, height, bpp)">sf::VideoMode</a>(800, 600), <span class="stringliteral">&quot;SFML window&quot;</span>);

 <span class="comment">// Limit the framerate to 60 frames per second (this step is optional)</span>
 window.setFramerateLimit(60);

 <span class="comment">// The main loop - ends as soon as the window is closed</span>
 <span class="keywordflow">while</span> (window.isOpen())
 {
    <span class="comment">// Event processing</span>
    <a class="code" href="classsf_1_1Event.htm" title="Defines a system event and its parameters.">sf::Event</a> event;
    <span class="keywordflow">while</span> (window.pollEvent(event))
    {
        <span class="comment">// Request for closing the window</span>
        <span class="keywordflow">if</span> (event.<a class="code" href="classsf_1_1Event.htm#adf2f8044f713fd9d6019077b0d1ffe0a" title="Type of the event.">type</a> == <a class="code" href="classsf_1_1Event.htm#af41fa9ed45c02449030699f671331d4aa316e4212e083f1dce79efd8d9e9c0a95" title="The window requested to be closed.">sf::Event::Closed</a>)
            window.close();
    }

    <span class="comment">// Clear the whole window before rendering a new frame</span>
    window.clear();

    <span class="comment">// Draw some graphical entities</span>
    window.draw(sprite);
    window.draw(circle);
    window.draw(text);

    <span class="comment">// End the current frame and display its contents on screen</span>
    window.display();
 }
</pre></div><p>Like <a class="el" href="classsf_1_1Window.htm" title="Window that serves as a target for OpenGL rendering.">sf::Window</a>, <a class="el" href="classsf_1_1RenderWindow.htm" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a> is still able to render direct OpenGL stuff. It is even possible to mix together OpenGL calls and regular SFML drawing commands.</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Create the render window</span>
 <a class="code" href="classsf_1_1RenderWindow.htm" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a> window(<a class="code" href="classsf_1_1VideoMode.htm" title="VideoMode defines a video mode (width, height, bpp)">sf::VideoMode</a>(800, 600), <span class="stringliteral">&quot;SFML OpenGL&quot;</span>);

 <span class="comment">// Create a sprite and a text to display</span>
 <a class="code" href="classsf_1_1Sprite.htm" title="Drawable representation of a texture, with its own transformations, color, etc.">sf::Sprite</a> sprite;
 <a class="code" href="classsf_1_1Text.htm" title="Graphical text that can be drawn to a render target.">sf::Text</a> text;
 ...

 <span class="comment">// Perform OpenGL initializations</span>
 glMatrixMode(GL_PROJECTION);
 ...

 <span class="comment">// Start the rendering loop</span>
 <span class="keywordflow">while</span> (window.isOpen())
 {
     <span class="comment">// Process events</span>
     ...

     <span class="comment">// Draw a background sprite</span>
     window.pushGLStates();
     window.draw(sprite);
     window.popGLStates();

     <span class="comment">// Draw a 3D object using OpenGL</span>
     glBegin(GL_QUADS);
         glVertex3f(...);
         ...
     glEnd();

     <span class="comment">// Draw text on top of the 3D object</span>
     window.pushGLStates();
     window.draw(text);
     window.popGLStates();

     <span class="comment">// Finally, display the rendered frame on screen</span>
     window.display();
 }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Window.htm" title="Window that serves as a target for OpenGL rendering.">sf::Window</a>, <a class="el" href="classsf_1_1RenderTarget.htm" title="Base class for all render targets (window, texture, ...)">sf::RenderTarget</a>, <a class="el" href="classsf_1_1RenderTexture.htm" title="Target for off-screen 2D rendering into an texture.">sf::RenderTexture</a>, <a class="el" href="classsf_1_1View.htm" title="2D camera that defines what region is shown on screen">sf::View</a> </dd></dl>

<p>Definition at line <a class="el" href="RenderWindow_8hpp_source.htm#l00044">44</a> of file <a class="el" href="RenderWindow_8hpp_source.htm">RenderWindow.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a839bbf336bdcafb084dafc3076fc9021"></a><!-- doxytag: member="sf::RenderWindow::RenderWindow" ref="a839bbf336bdcafb084dafc3076fc9021" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1RenderWindow.htm#a839bbf336bdcafb084dafc3076fc9021">sf::RenderWindow::RenderWindow</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>This constructor doesn't actually create the window, use the other constructors or call Create to do so. </p>

</div>
</div>
<a class="anchor" id="a828cf38403a246c11ae98a316f271941"></a><!-- doxytag: member="sf::RenderWindow::RenderWindow" ref="a828cf38403a246c11ae98a316f271941" args="(VideoMode mode, const std::string &amp;title, Uint32 style=Style::Default, const ContextSettings &amp;settings=ContextSettings())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1RenderWindow.htm#a839bbf336bdcafb084dafc3076fc9021">sf::RenderWindow::RenderWindow</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VideoMode.htm">VideoMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>style</em> = <code>Style::Default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a new window. </p>
<p>This constructor creates the window with the size and pixel depth defined in <em>mode</em>. An optional style can be passed to customize the look and behaviour of the window (borders, title bar, resizable, closable, ...).</p>
<p>The fourth parameter is an optional structure specifying advanced OpenGL context settings such as antialiasing, depth-buffer bits, etc. You shouldn't care about these parameters for a regular usage of the graphics module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Video mode to use (defines the width, height and depth of the rendering area of the window) </td></tr>
    <tr><td class="paramname">title</td><td>Title of the window </td></tr>
    <tr><td class="paramname">style</td><td><a class="el" href="classsf_1_1Window.htm" title="Window that serves as a target for OpenGL rendering.">Window</a> style </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings for the underlying OpenGL context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25c0af7d515e710b6eebc9c6be952aa5"></a><!-- doxytag: member="sf::RenderWindow::RenderWindow" ref="a25c0af7d515e710b6eebc9c6be952aa5" args="(WindowHandle handle, const ContextSettings &amp;settings=ContextSettings())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1RenderWindow.htm#a839bbf336bdcafb084dafc3076fc9021">sf::RenderWindow::RenderWindow</a> </td>
          <td>(</td>
          <td class="paramtype">WindowHandle&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the window from an existing control. </p>
<p>Use this constructor if you want to create an SFML rendering area into an already existing control.</p>
<p>The fourth parameter is an optional structure specifying advanced OpenGL context settings such as antialiasing, depth-buffer bits, etc. You shouldn't care about these parameters for a regular usage of the graphics module.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Platform-specific handle of the control </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings for the underlying OpenGL context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3407e36bfc1752d723140438a825365c"></a><!-- doxytag: member="sf::RenderWindow::~RenderWindow" ref="a3407e36bfc1752d723140438a825365c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsf_1_1RenderWindow.htm#a3407e36bfc1752d723140438a825365c">sf::RenderWindow::~RenderWindow</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Closes the window and free all the resources attached to it. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aefd4b1cc8e264598b94bd70aaac5bc99"></a><!-- doxytag: member="sf::RenderWindow::applyBlendMode" ref="aefd4b1cc8e264598b94bd70aaac5bc99" args="(BlendMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#aefd4b1cc8e264598b94bd70aaac5bc99">sf::RenderTarget::applyBlendMode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__graphics.htm#ga80c52fe2f7050d7f7573b7ed3c995388">BlendMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a new blending mode. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Blending mode to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ed439c5445e9c7d7ff786ff37005efa"></a><!-- doxytag: member="sf::RenderWindow::applyCurrentView" ref="a3ed439c5445e9c7d7ff786ff37005efa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a3ed439c5445e9c7d7ff786ff37005efa">sf::RenderTarget::applyCurrentView</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply the current view. </p>

</div>
</div>
<a class="anchor" id="a6f8bc92f07c70ccd57cbf632fe9de0ba"></a><!-- doxytag: member="sf::RenderWindow::applyShader" ref="a6f8bc92f07c70ccd57cbf632fe9de0ba" args="(const Shader *shader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a6f8bc92f07c70ccd57cbf632fe9de0ba">sf::RenderTarget::applyShader</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Shader.htm">Shader</a> *&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a new shader. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td><a class="el" href="classsf_1_1Shader.htm" title="Shader class (vertex and fragment)">Shader</a> to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb8a49305171aad158a27e0dfbb03709"></a><!-- doxytag: member="sf::RenderWindow::applyTexture" ref="afb8a49305171aad158a27e0dfbb03709" args="(const Texture *texture)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#afb8a49305171aad158a27e0dfbb03709">sf::RenderTarget::applyTexture</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Texture.htm">Texture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a new texture. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td><a class="el" href="classsf_1_1Texture.htm" title="Image living on the graphics card that can be used for drawing.">Texture</a> to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b23bd7c287d0fc12b0521b649a0a0e0"></a><!-- doxytag: member="sf::RenderWindow::applyTransform" ref="a0b23bd7c287d0fc12b0521b649a0a0e0" args="(const Transform &amp;transform)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a0b23bd7c287d0fc12b0521b649a0a0e0">sf::RenderTarget::applyTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Transform.htm">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a new transform. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td><a class="el" href="classsf_1_1Transform.htm" title="Define a 3x3 transform matrix.">Transform</a> to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bd8655d0bac83145bfc329ea7a6d538"></a><!-- doxytag: member="sf::RenderWindow::capture" ref="a9bd8655d0bac83145bfc329ea7a6d538" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Image.htm">Image</a> <a class="el" href="classsf_1_1RenderWindow.htm#a9bd8655d0bac83145bfc329ea7a6d538">sf::RenderWindow::capture</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the current contents of the window to an image. </p>
<p>This is a slow operation, whose main purpose is to make screenshots of the application. If you want to update an image with the contents of the window and then use it for drawing, you should rather use a <a class="el" href="classsf_1_1Texture.htm" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> and its update(Window&amp;) function. You can also draw things directly to a texture with the <a class="el" href="classsf_1_1RenderTexture.htm" title="Target for off-screen 2D rendering into an texture.">sf::RenderTexture</a> class.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classsf_1_1Image.htm" title="Class for loading, manipulating and saving images.">Image</a> containing the captured contents </dd></dl>

</div>
</div>
<a class="anchor" id="a6bb6f0ba348f2b1e2f46114aeaf60f26"></a><!-- doxytag: member="sf::RenderWindow::clear" ref="a6bb6f0ba348f2b1e2f46114aeaf60f26" args="(const Color &amp;color=Color(0, 0, 0, 255))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a6bb6f0ba348f2b1e2f46114aeaf60f26">sf::RenderTarget::clear</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Color.htm">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="classsf_1_1Color.htm">Color</a>(0,&#160;0,&#160;0,&#160;255)</code></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the entire target with a single color. </p>
<p>This function is usually called once every frame, to clear the previous contents of the target.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Fill color to use to clear the render target </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99d1e030387b0c26f5995670504fe7b5"></a><!-- doxytag: member="sf::RenderWindow::close" ref="a99d1e030387b0c26f5995670504fe7b5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#a99d1e030387b0c26f5995670504fe7b5">sf::Window::close</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close the window and destroy all the attached resources. </p>
<p>After calling this function, the <a class="el" href="classsf_1_1Window.htm" title="Window that serves as a target for OpenGL rendering.">sf::Window</a> instance remains valid and you can call <a class="el" href="classsf_1_1Window.htm#a21c51afab5ae676c9c8b325d453958d5" title="Create (or recreate) the window.">create()</a> to recreate the window. All other functions such as <a class="el" href="classsf_1_1Window.htm#a338e996585faf82e93069858e3b531b7" title="Pop the event on top of events stack, if any, and return it.">pollEvent()</a> or <a class="el" href="classsf_1_1Window.htm#adabf839cb103ac96cfc82f781638772a" title="Display on screen what has been rendered to the window so far.">display()</a> will still work (i.e. you don't have to test <a class="el" href="classsf_1_1Window.htm#a5aa9c2b2b0e51d3423c2b66c80253337" title="Tell whether or not the window is open.">isOpen()</a> every time), and will have no effect on closed windows. </p>

</div>
</div>
<a class="anchor" id="afc047333937f7cb7fe557aec60239233"></a><!-- doxytag: member="sf::RenderWindow::convertCoords" ref="afc047333937f7cb7fe557aec60239233" args="(const Vector2i &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2f</a> <a class="el" href="classsf_1_1RenderTarget.htm#afc047333937f7cb7fe557aec60239233">sf::RenderTarget::convertCoords</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Vector2.htm">Vector2i</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a point from target coordinates to view coordinates. </p>
<p>Initially, a unit of the 2D world matches a pixel of the render target. But if you define a custom view, this assertion is not true anymore, ie. a point located at (10, 50) in your render target (for example a window) may map to the point (150, 75) in your 2D world -- for example if the view is translated by (140, 25).</p>
<p>For render windows, this function is typically used to find which point (or object) is located below the mouse cursor.</p>
<p>This version uses the current view of the render target. See the other overload to specify a custom view.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point to convert, relative to the render target</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The converted point, in "world" units </dd></dl>

</div>
</div>
<a class="anchor" id="ae5e7ba65ef73df2778b29b7fdcdb20ee"></a><!-- doxytag: member="sf::RenderWindow::convertCoords" ref="ae5e7ba65ef73df2778b29b7fdcdb20ee" args="(const Vector2i &amp;point, const View &amp;view) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2f</a> <a class="el" href="classsf_1_1RenderTarget.htm#afc047333937f7cb7fe557aec60239233">sf::RenderTarget::convertCoords</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Vector2.htm">Vector2i</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.htm">View</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a point from target coordinates to view coordinates. </p>
<p>Initially, a unit of the 2D world matches a pixel of the render target. But if you define a custom view, this assertion is not true anymore, ie. a point located at (10, 50) in your render target (for example a window) may map to the point (150, 75) in your 2D world -- for example if the view is translated by (140, 25).</p>
<p>For render windows, this function is typically used to find which point (or object) is located below the mouse cursor.</p>
<p>This version uses a custom view for calculations, see the other overload of the function to use the current view of the render target.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point to convert, relative to the render target </td></tr>
    <tr><td class="paramname">view</td><td>The view to use for converting the point</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The converted point, in "world" units </dd></dl>

</div>
</div>
<a class="anchor" id="a21c51afab5ae676c9c8b325d453958d5"></a><!-- doxytag: member="sf::RenderWindow::create" ref="a21c51afab5ae676c9c8b325d453958d5" args="(VideoMode mode, const std::string &amp;title, Uint32 style=Style::Default, const ContextSettings &amp;settings=ContextSettings())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#a21c51afab5ae676c9c8b325d453958d5">sf::Window::create</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VideoMode.htm">VideoMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>style</em> = <code>Style::Default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create (or recreate) the window. </p>
<p>If the window was already created, it closes it first. If <em>style</em> contains Style::Fullscreen, then <em>mode</em> must be a valid video mode.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Video mode to use (defines the width, height and depth of the rendering area of the window) </td></tr>
    <tr><td class="paramname">title</td><td>Title of the window </td></tr>
    <tr><td class="paramname">style</td><td><a class="el" href="classsf_1_1Window.htm" title="Window that serves as a target for OpenGL rendering.">Window</a> style </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings for the underlying OpenGL context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf67483dc21f08d65c8835b3889b41b2"></a><!-- doxytag: member="sf::RenderWindow::create" ref="acf67483dc21f08d65c8835b3889b41b2" args="(WindowHandle handle, const ContextSettings &amp;settings=ContextSettings())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#a21c51afab5ae676c9c8b325d453958d5">sf::Window::create</a> </td>
          <td>(</td>
          <td class="paramtype">WindowHandle&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create (or recreate) the window from an existing control. </p>
<p>Use this function if you want to create an OpenGL rendering area into an already existing control. If the window was already created, it closes it first.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Platform-specific handle of the control </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings for the underlying OpenGL context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adabf839cb103ac96cfc82f781638772a"></a><!-- doxytag: member="sf::RenderWindow::display" ref="adabf839cb103ac96cfc82f781638772a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#adabf839cb103ac96cfc82f781638772a">sf::Window::display</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Display on screen what has been rendered to the window so far. </p>
<p>This function is typically called after all OpenGL rendering has been done for the current frame, in order to show it on screen. </p>

</div>
</div>
<a class="anchor" id="a12417a3bcc245c41d957b29583556f39"></a><!-- doxytag: member="sf::RenderWindow::draw" ref="a12417a3bcc245c41d957b29583556f39" args="(const Drawable &amp;drawable, const RenderStates &amp;states=RenderStates::Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a12417a3bcc245c41d957b29583556f39">sf::RenderTarget::draw</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Drawable.htm">Drawable</a> &amp;&#160;</td>
          <td class="paramname"><em>drawable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1RenderStates.htm">RenderStates</a> &amp;&#160;</td>
          <td class="paramname"><em>states</em> = <code><a class="el" href="classsf_1_1RenderStates.htm#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a drawable object to the render-target. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">drawable</td><td>Object to draw </td></tr>
    <tr><td class="paramname">states</td><td>Render states to use for drawing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab636d7363f6681077361ee274ba89a8d"></a><!-- doxytag: member="sf::RenderWindow::draw" ref="ab636d7363f6681077361ee274ba89a8d" args="(const Vertex *vertices, unsigned int vertexCount, PrimitiveType type, const RenderStates &amp;states=RenderStates::Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a12417a3bcc245c41d957b29583556f39">sf::RenderTarget::draw</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Vertex.htm">Vertex</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graphics.htm#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1RenderStates.htm">RenderStates</a> &amp;&#160;</td>
          <td class="paramname"><em>states</em> = <code><a class="el" href="classsf_1_1RenderStates.htm#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw primitives defined by an array of vertices. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to the vertices </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Number of vertices in the array </td></tr>
    <tr><td class="paramname">type</td><td>Type of primitives to draw </td></tr>
    <tr><td class="paramname">states</td><td>Render states to use for drawing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a718b1aa6296bf855171699cc18251ced"></a><!-- doxytag: member="sf::RenderWindow::getDefaultView" ref="a718b1aa6296bf855171699cc18251ced" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsf_1_1View.htm">View</a>&amp; <a class="el" href="classsf_1_1RenderTarget.htm#a718b1aa6296bf855171699cc18251ced">sf::RenderTarget::getDefaultView</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the default view of the render target. </p>
<p>The default view has the initial size of the render target, and never changes after the target has been created.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The default view of the render target</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTarget.htm#a063db6dd0a14913504af30e50cb6d946" title="Change the current active view.">setView</a>, <a class="el" href="classsf_1_1RenderTarget.htm#a98f721cc6dc11478922427fedfb2288b" title="Get the view currently in use in the render target.">getView</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2e6bc12612ea289afea8268fe37c8678"></a><!-- doxytag: member="sf::RenderWindow::getPosition" ref="a2e6bc12612ea289afea8268fe37c8678" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.htm">Vector2i</a> <a class="el" href="classsf_1_1Window.htm#a2e6bc12612ea289afea8268fe37c8678">sf::Window::getPosition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the position of the window. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of the window, in pixels</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Window.htm#a6c4078bfbf61c29bfc4b4732ce764f17" title="Change the position of the window on screen.">setPosition</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a9d5c15facf25ad4d9b2b30caa0a2db"></a><!-- doxytag: member="sf::RenderWindow::getSettings" ref="a5a9d5c15facf25ad4d9b2b30caa0a2db" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsf_1_1ContextSettings.htm">ContextSettings</a>&amp; <a class="el" href="classsf_1_1Window.htm#a5a9d5c15facf25ad4d9b2b30caa0a2db">sf::Window::getSettings</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the settings of the OpenGL context of the window. </p>
<p>Note that these settings may be different from what was passed to the constructor or the <a class="el" href="classsf_1_1Window.htm#a21c51afab5ae676c9c8b325d453958d5" title="Create (or recreate) the window.">create()</a> function, if one or more settings were not supported. In this case, SFML chose the closest match.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Structure containing the OpenGL context settings </dd></dl>

</div>
</div>
<a class="anchor" id="a2c7ff414be32621a453745cf2a0f8a3e"></a><!-- doxytag: member="sf::RenderWindow::getSize" ref="a2c7ff414be32621a453745cf2a0f8a3e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsf_1_1Vector2.htm">Vector2u</a> <a class="el" href="classsf_1_1RenderWindow.htm#a2c7ff414be32621a453745cf2a0f8a3e">sf::RenderWindow::getSize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the size of the rendering region of the window. </p>
<p>The size doesn't include the titlebar and borders of the window.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Size in pixels </dd></dl>

<p>Implements <a class="el" href="classsf_1_1RenderTarget.htm#a2e5ade2457d9fb4c4907ae5b3d9e94a5">sf::RenderTarget</a>.</p>

</div>
</div>
<a class="anchor" id="a26368e7162229f8637c34d80ab0f138e"></a><!-- doxytag: member="sf::RenderWindow::getSystemHandle" ref="a26368e7162229f8637c34d80ab0f138e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WindowHandle <a class="el" href="classsf_1_1Window.htm#a26368e7162229f8637c34d80ab0f138e">sf::Window::getSystemHandle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the OS-specific handle of the window. </p>
<p>The type of the returned handle is sf::WindowHandle, which is a typedef to the handle type defined by the OS. You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>System handle of the window </dd></dl>

</div>
</div>
<a class="anchor" id="a98f721cc6dc11478922427fedfb2288b"></a><!-- doxytag: member="sf::RenderWindow::getView" ref="a98f721cc6dc11478922427fedfb2288b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsf_1_1View.htm">View</a>&amp; <a class="el" href="classsf_1_1RenderTarget.htm#a98f721cc6dc11478922427fedfb2288b">sf::RenderTarget::getView</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the view currently in use in the render target. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The view object that is currently used</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTarget.htm#a063db6dd0a14913504af30e50cb6d946" title="Change the current active view.">setView</a>, <a class="el" href="classsf_1_1RenderTarget.htm#a718b1aa6296bf855171699cc18251ced" title="Get the default view of the render target.">getDefaultView</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aae035b0d45f87a0da2a28a0de6ba1086"></a><!-- doxytag: member="sf::RenderWindow::getViewport" ref="aae035b0d45f87a0da2a28a0de6ba1086" args="(const View &amp;view) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Rect.htm">IntRect</a> <a class="el" href="classsf_1_1RenderTarget.htm#aae035b0d45f87a0da2a28a0de6ba1086">sf::RenderTarget::getViewport</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.htm">View</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the viewport of a view, applied to this render target. </p>
<p>The viewport is defined in the view as a ratio, this function simply applies this ratio to the current dimensions of the render target to calculate the pixels rectangle that the viewport actually covers in the target.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>The view for which we want to compute the viewport</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Viewport rectangle, expressed in pixels </dd></dl>

</div>
</div>
<a class="anchor" id="af530274b34159d644e509b4b4dc43eb7"></a><!-- doxytag: member="sf::RenderWindow::initialize" ref="af530274b34159d644e509b4b4dc43eb7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#af530274b34159d644e509b4b4dc43eb7">sf::RenderTarget::initialize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the common initialization step after creation. </p>
<p>The derived classes must call this function after the target is created and ready for drawing. </p>

</div>
</div>
<a class="anchor" id="a5aa9c2b2b0e51d3423c2b66c80253337"></a><!-- doxytag: member="sf::RenderWindow::isOpen" ref="a5aa9c2b2b0e51d3423c2b66c80253337" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1Window.htm#a5aa9c2b2b0e51d3423c2b66c80253337">sf::Window::isOpen</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell whether or not the window is open. </p>
<p>This function returns whether or not the window exists. Note that a hidden window (setVisible(false)) is open (therefore this function would return true).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the window is open, false if it has been closed </dd></dl>

</div>
</div>
<a class="anchor" id="a5bef0040b0fa87bed9fbd459c980d53a"></a><!-- doxytag: member="sf::RenderWindow::onCreate" ref="a5bef0040b0fa87bed9fbd459c980d53a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsf_1_1RenderWindow.htm#a5bef0040b0fa87bed9fbd459c980d53a">sf::RenderWindow::onCreate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function called after the window has been created. </p>
<p>This function is called so that derived classes can perform their own specific initialization as soon as the window is created. </p>

<p>Reimplemented from <a class="el" href="classsf_1_1Window.htm#a106633b9be49b27f83d4712689b493eb">sf::Window</a>.</p>

</div>
</div>
<a class="anchor" id="a5c85fe482313562d33ffd24a194b6fef"></a><!-- doxytag: member="sf::RenderWindow::onResize" ref="a5c85fe482313562d33ffd24a194b6fef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsf_1_1RenderWindow.htm#a5c85fe482313562d33ffd24a194b6fef">sf::RenderWindow::onResize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function called after the window has been resized. </p>
<p>This function is called so that derived classes can perform custom actions when the size of the window changes. </p>

<p>Reimplemented from <a class="el" href="classsf_1_1Window.htm#a10f567a387da7b49f417f73321fcf64d">sf::Window</a>.</p>

</div>
</div>
<a class="anchor" id="a338e996585faf82e93069858e3b531b7"></a><!-- doxytag: member="sf::RenderWindow::pollEvent" ref="a338e996585faf82e93069858e3b531b7" args="(Event &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1Window.htm#a338e996585faf82e93069858e3b531b7">sf::Window::pollEvent</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Event.htm">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pop the event on top of events stack, if any, and return it. </p>
<p>This function is not blocking: if there's no pending event then it will return false and leave <em>event</em> unmodified. Note that more than one event may be present in the events stack, thus you should always call this function in a loop to make sure that you process every pending event. </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classsf_1_1Event.htm" title="Defines a system event and its parameters.">sf::Event</a> event;
 <span class="keywordflow">while</span> (window.pollEvent(event))
 {
    <span class="comment">// process event...</span>
 }
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="classsf_1_1Event.htm" title="Defines a system event and its parameters.">Event</a> to be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if an event was returned, or false if the events stack was empty</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Window.htm#aaf02ab64fbc1d374eef3696df54137bc" title="Wait for an event and return it.">waitEvent</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad5a98401113df931ddcd54c080f7aa8e"></a><!-- doxytag: member="sf::RenderWindow::popGLStates" ref="ad5a98401113df931ddcd54c080f7aa8e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#ad5a98401113df931ddcd54c080f7aa8e">sf::RenderTarget::popGLStates</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restore the previously saved OpenGL render states and matrices. </p>
<p>See the description of pushGLStates to get a detailed description of these functions.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTarget.htm#a8d1998464ccc54e789aaf990242b47f7" title="Save the current OpenGL render states and matrices.">pushGLStates</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8d1998464ccc54e789aaf990242b47f7"></a><!-- doxytag: member="sf::RenderWindow::pushGLStates" ref="a8d1998464ccc54e789aaf990242b47f7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a8d1998464ccc54e789aaf990242b47f7">sf::RenderTarget::pushGLStates</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save the current OpenGL render states and matrices. </p>
<p>This function can be used when you mix SFML drawing and direct OpenGL rendering. Combined with PopGLStates, it ensures that: </p>
<ul>
<li>SFML's internal states are not messed up by your OpenGL code </li>
<li>your OpenGL states are not modified by a call to a SFML function</li>
</ul>
<p>More specifically, it must be used around code that calls Draw functions. Example: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// OpenGL code here...</span>
 window.pushGLStates();
 window.draw(...);
 window.draw(...);
 window.popGLStates();
 <span class="comment">// OpenGL code here...</span>
</pre></div><p>Note that this function is quite expensive: it saves all the possible OpenGL states and matrices, even the ones you don't care about. Therefore it should be used wisely. It is provided for convenience, but the best results will be achieved if you handle OpenGL states yourself (because you know which states have really changed, and need to be saved and restored). Take a look at the ResetGLStates function if you do so.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTarget.htm#ad5a98401113df931ddcd54c080f7aa8e" title="Restore the previously saved OpenGL render states and matrices.">popGLStates</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aac7504990d27dada4bfe3c7866920765"></a><!-- doxytag: member="sf::RenderWindow::resetGLStates" ref="aac7504990d27dada4bfe3c7866920765" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#aac7504990d27dada4bfe3c7866920765">sf::RenderTarget::resetGLStates</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the internal OpenGL states so that the target is ready for drawing. </p>
<p>This function can be used when you mix SFML drawing and direct OpenGL rendering, if you choose not to use pushGLStates/popGLStates. It makes sure that all OpenGL states needed by SFML are set, so that subsequent <a class="el" href="classsf_1_1RenderTarget.htm#a12417a3bcc245c41d957b29583556f39" title="Draw a drawable object to the render-target.">draw()</a> calls will work as expected.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// OpenGL code here...</span>
 glPushAttrib(...);
 window.resetGLStates();
 window.draw(...);
 window.draw(...);
 glPopAttrib(...);
 <span class="comment">// OpenGL code here...</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="a17ccf8ece0ce0bf2f1e6698bcfa29731"></a><!-- doxytag: member="sf::RenderWindow::setActive" ref="a17ccf8ece0ce0bf2f1e6698bcfa29731" args="(bool active=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1Window.htm#a17ccf8ece0ce0bf2f1e6698bcfa29731">sf::Window::setActive</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Activate or deactivate the window as the current target for OpenGL rendering. </p>
<p>A window is active only on the current thread, if you want to make it active on another thread you have to deactivate it on the previous thread first if it was active. Only one window can be active on a thread at a time, thus the window previously active (if any) automatically gets deactivated.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>True to activate, false to deactivate</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if operation was successful, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="af4322d315baf93405bf0d5087ad5e784"></a><!-- doxytag: member="sf::RenderWindow::setFramerateLimit" ref="af4322d315baf93405bf0d5087ad5e784" args="(unsigned int limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#af4322d315baf93405bf0d5087ad5e784">sf::Window::setFramerateLimit</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Limit the framerate to a maximum fixed frequency. </p>
<p>If a limit is set, the window will use a small delay after each call to <a class="el" href="classsf_1_1Window.htm#adabf839cb103ac96cfc82f781638772a" title="Display on screen what has been rendered to the window so far.">display()</a> to ensure that the current frame lasted long enough to match the framerate limit. SFML will try to match the given limit as much as it can, but since it internally uses sf::sleep, whose precision depends on the underlying OS, the results may be a little unprecise as well (for example, you can get 65 FPS when requesting 60).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>Framerate limit, in frames per seconds (use 0 to disable limit) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63af61e026fba08e3153fd013620bcc0"></a><!-- doxytag: member="sf::RenderWindow::setIcon" ref="a63af61e026fba08e3153fd013620bcc0" args="(unsigned int width, unsigned int height, const Uint8 *pixels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#a63af61e026fba08e3153fd013620bcc0">sf::Window::setIcon</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint8 *&#160;</td>
          <td class="paramname"><em>pixels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the window's icon. </p>
<p><em>pixels</em> must be an array of <em>width</em> x <em>height</em> pixels in 32-bits RGBA format.</p>
<p>The OS default icon is used by default.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Icon's width, in pixels </td></tr>
    <tr><td class="paramname">height</td><td>Icon's height, in pixels </td></tr>
    <tr><td class="paramname">pixels</td><td>Pointer to the array of pixels in memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Window.htm#a7f419f99a799424376aba838abfbd273" title="Change the title of the window.">setTitle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa45b8f54e29a6f59f1fc7ee66b2fab68"></a><!-- doxytag: member="sf::RenderWindow::setJoystickThreshold" ref="aa45b8f54e29a6f59f1fc7ee66b2fab68" args="(float threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#aa45b8f54e29a6f59f1fc7ee66b2fab68">sf::Window::setJoystickThreshold</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the joystick threshold. </p>
<p>The joystick threshold is the value below which no JoystickMoved event will be generated.</p>
<p>The threshold value is 0.1 by default.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>New threshold, in the range [0, 100] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef9f2b14c10ecba8a8df95dd51c5bb73"></a><!-- doxytag: member="sf::RenderWindow::setKeyRepeatEnabled" ref="aef9f2b14c10ecba8a8df95dd51c5bb73" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#aef9f2b14c10ecba8a8df95dd51c5bb73">sf::Window::setKeyRepeatEnabled</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable automatic key-repeat. </p>
<p>If key repeat is enabled, you will receive repeated KeyPressed events while keeping a key pressed. If it is disabled, you will only get a single event when the key is pressed.</p>
<p>Key repeat is enabled by default.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>True to enable, false to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad3991c25e0a83afbb4d62febf9b7b14"></a><!-- doxytag: member="sf::RenderWindow::setMouseCursorVisible" ref="aad3991c25e0a83afbb4d62febf9b7b14" args="(bool visible)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#aad3991c25e0a83afbb4d62febf9b7b14">sf::Window::setMouseCursorVisible</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Show or hide the mouse cursor. </p>
<p>The mouse cursor is visible by default.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">visible</td><td>True to show the mouse cursor, false to hide it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c4078bfbf61c29bfc4b4732ce764f17"></a><!-- doxytag: member="sf::RenderWindow::setPosition" ref="a6c4078bfbf61c29bfc4b4732ce764f17" args="(const Vector2i &amp;position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#a6c4078bfbf61c29bfc4b4732ce764f17">sf::Window::setPosition</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Vector2.htm">Vector2i</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the position of the window on screen. </p>
<p>This function only works for top-level windows (i.e. it will be ignored for windows created from the handle of a child window/control).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>New position, in pixels</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Window.htm#a2e6bc12612ea289afea8268fe37c8678" title="Get the position of the window.">getPosition</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad6513418bb2963347cd1819a1810524d"></a><!-- doxytag: member="sf::RenderWindow::setSize" ref="ad6513418bb2963347cd1819a1810524d" args="(const Vector2u size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#ad6513418bb2963347cd1819a1810524d">sf::Window::setSize</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Vector2.htm">Vector2u</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the size of the rendering region of the window. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>New size, in pixels</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Window.htm#ad2b55a731ba1680fe67292991ef1610e" title="Get the size of the rendering region of the window.">getSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7f419f99a799424376aba838abfbd273"></a><!-- doxytag: member="sf::RenderWindow::setTitle" ref="a7f419f99a799424376aba838abfbd273" args="(const std::string &amp;title)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#a7f419f99a799424376aba838abfbd273">sf::Window::setTitle</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the title of the window. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">title</td><td>New title</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Window.htm#a63af61e026fba08e3153fd013620bcc0" title="Change the window&#39;s icon.">setIcon</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a59041c4556e0351048f8aff366034f61"></a><!-- doxytag: member="sf::RenderWindow::setVerticalSyncEnabled" ref="a59041c4556e0351048f8aff366034f61" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#a59041c4556e0351048f8aff366034f61">sf::Window::setVerticalSyncEnabled</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable vertical synchronization. </p>
<p>Activating vertical synchronization will limit the number of frames displayed to the refresh rate of the monitor. This can avoid some visual artifacts, and limit the framerate to a good value (but not constant across different computers).</p>
<p>Vertical synchronization is disabled by default.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>True to enable v-sync, false to deactivate it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a063db6dd0a14913504af30e50cb6d946"></a><!-- doxytag: member="sf::RenderWindow::setView" ref="a063db6dd0a14913504af30e50cb6d946" args="(const View &amp;view)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1RenderTarget.htm#a063db6dd0a14913504af30e50cb6d946">sf::RenderTarget::setView</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.htm">View</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the current active view. </p>
<p>The view is like a 2D camera, it controls which part of the 2D scene is visible, and how it is viewed in the render-target. The new view will affect everything that is drawn, until another view is set. The render target keeps its own copy of the view object, so it is not necessary to keep the original one alive after calling this function. To restore the original view of the target, you can pass the result of <a class="el" href="classsf_1_1RenderTarget.htm#a718b1aa6296bf855171699cc18251ced" title="Get the default view of the render target.">getDefaultView()</a> to this function.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>New view to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1RenderTarget.htm#a98f721cc6dc11478922427fedfb2288b" title="Get the view currently in use in the render target.">getView</a>, <a class="el" href="classsf_1_1RenderTarget.htm#a718b1aa6296bf855171699cc18251ced" title="Get the default view of the render target.">getDefaultView</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a160f7f11a207603d7e99ce606e749703"></a><!-- doxytag: member="sf::RenderWindow::setVisible" ref="a160f7f11a207603d7e99ce606e749703" args="(bool visible)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsf_1_1Window.htm#a160f7f11a207603d7e99ce606e749703">sf::Window::setVisible</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Show or hide the window. </p>
<p>The window is shown by default.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">visible</td><td>True to show the window, false to hide it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf02ab64fbc1d374eef3696df54137bc"></a><!-- doxytag: member="sf::RenderWindow::waitEvent" ref="aaf02ab64fbc1d374eef3696df54137bc" args="(Event &amp;event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsf_1_1Window.htm#aaf02ab64fbc1d374eef3696df54137bc">sf::Window::waitEvent</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Event.htm">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for an event and return it. </p>
<p>This function is blocking: if there's no pending event then it will wait until an event is received. After this function returns (and no error occured), the <em>event</em> object is always valid and filled properly. This function is typically used when you have a thread that is dedicated to events handling: you want to make this thread sleep as long as no new event is received. </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classsf_1_1Event.htm" title="Defines a system event and its parameters.">sf::Event</a> event;
 <span class="keywordflow">if</span> (window.waitEvent(event))
 {
    <span class="comment">// process event...</span>
 }
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td><a class="el" href="classsf_1_1Event.htm" title="Defines a system event and its parameters.">Event</a> to be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>False if any error occured</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classsf_1_1Window.htm#a338e996585faf82e93069858e3b531b7" title="Pop the event on top of events stack, if any, and return it.">pollEvent</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="RenderWindow_8hpp_source.htm">RenderWindow.hpp</a></li>
</ul>
</div><!-- contents -->

        <p id="footer">
            &nbsp;::&nbsp; Copyright &copy; 2007-2008 Laurent Gomila, all rights reserved &nbsp;::&nbsp;
            Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen 1.5.2</a> &nbsp;::&nbsp;
        </p>

    </body>
</html>
